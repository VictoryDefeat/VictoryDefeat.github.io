<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅析sort]]></title>
    <url>%2F%E6%B5%85%E6%9E%90sort%2F</url>
    <content type="text"><![CDATA[0.前言相信每个入门的同学都见过这样一个题目： 给定一些整数，将它们从小到大排序后输出 同学们常常会写这样的代码： 123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[1000010];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i)scanf("%d",&amp;a[i]); sort(a+1,a+1+n); for(int i=1;i&lt;n;++i)printf("%d ",a[i]); printf("%d\n",a[n]); return 0;&#125; 这里的sort就是我们今天的主角 别看它语句短小，但却无比精悍 1.观察首先，观察sort的来源（我这里使用了VSCode的速览定义功能） 观察到它包含在stl_algo.h文件中（这一文件包含在algorithm头文件中） 找到其定义为 123456789101112131415161718192021template&lt;typename _RandomAccessIterator&gt; inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __last) &#123; typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type_ValueType; // concept requirements __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept&lt; _RandomAccessIterator&gt;) __glibcxx_function_requires(_LessThanComparableConcept&lt;_ValueType&gt;) __glibcxx_requires_valid_range(__first, __last);//start if (__first != __last)&#123; std::__introsort_loop(__first, __last, std::__lg(__last - __first) * 2); std::__final_insertion_sort(__first, __last);&#125; //end &#125;//这里吐槽一下C++ STL编写者的码风 看到变量是_RandomAccessIterator（即随机迭代器） 这是个什么东西鸭？其实就是数组、vector、deque这类东西的实现方法 接下来观察到其主体代码是从//start到//end的部分，前面可以不管 2.深入分析2.1 __introsort_loop这是个什么玩意？ 12345678910111213141516171819202122template&lt;typename _RandomAccessIterator, typename _Size, typename _Compare&gt; void __introsort_loop(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp) &#123; while (__last - __first &gt; int(_S_threshold))//5&#123; if (__depth_limit == 0) &#123; _GLIBCXX_STD_A::partial_sort(__first, __last, __last, __comp);//4 return; &#125; //1 --__depth_limit; _RandomAccessIterator __cut = std::__unguarded_partition_pivot(__first, __last, __comp);//3 std::__introsort_loop(__cut, __last, __depth_limit, __comp); __last = __cut; //2&#125; &#125; 如上是其源码，发现它是一个递归结构 2.1.1 //1到//2不难看出//1与//2之间正是快速排序实现 然而……貌似它只处理了右区间部分？左区间怎么办呢？ 别急，我们来重新浏览一下： 它在排完序之后把cut的值付给了last 然后由于它是循环，所以……下一次就是处理左区间了 所以它相比于我们所写的排序优点正是此处 巧妙地将递归换成了循环，虽然复杂度不变，但常数就是大幅提升了 这似乎从一方面解释了sort比手写排序快的原因（借用一个图）： 2.1.2 //3不过这并不能让快排避免退化的危机，只能解决常数问题 然而sort似乎基本没有退化过，这是为什么呢？ 首先注意//3处（pivot就是常说的哨兵） 这里的哨兵并没有使用start，last，comp中的任何一个 通过持续跟踪，发现哨兵使用的是三者的中值 这就从一定程度上优化了算法 （据说//3处是分割算法，然而本人未发现其实际作用，故此处暂不分析） 2.1.3 //4这个partial_sort是什么？为什么要用它？ 通过调查源码，发现这个partial_sort就是堆排： 那么depth_limit是什么？有何作用？ 回到sort本体，发现depth_limit即$\log_2(last-first)$（亦即$\log_2n$） 如果递归次数到达$\log_2n$会怎么样？ 退化，在退化之际使用堆排来弥补，可以基本解决退化 这也正是sort不退化的奥秘所在 2.2 __final_insertion_sort这……终极插入排序？（雾） 前面不是排好了么？要它何用？ 等等，回到$2.1$的//5处，这个_S_threshold是？ 查阅定义得，_S_threshold为$16$，一个常数？ 所以说……快排剩了最前面$16$个不排，交给插入排序？ 理论上就算退化复杂度也才相当于插入排序啊，为什么呢？ 这时就需要复习一下插排的概念了 2.2.1 插排复习插排原理：每一个元素通过比较，找到应插入位置 其特点：最好情况（基本有序）复杂度$O(n)$ 这样就可以理解了，快排保证了前$16$个元素基本有序，但非完全有序 所以，这样只要$O(n)$就可以排好最左边$16$个 2.2.2 分析以为这就结束了？想的太简单了 观察__final_insertion_sort源码： 1234567891011121314template&lt;typename _RandomAccessIterator, typename _Compare&gt; void __final_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) &#123; if (__last - __first &gt; int(_S_threshold)) &#123; std::__insertion_sort(__first, __first + int(_S_threshold), __comp); std::__unguarded_insertion_sort(__first + int(_S_threshold), __last, __comp); &#125; else std::__insertion_sort(__first, __last, __comp); &#125; 可以看到，又调用了两个插入排序，它们分别的代码： 1234567891011121314151617181920template&lt;typename _RandomAccessIterator, typename _Compare&gt; void __insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) &#123; if (__first == __last) return; for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i) &#123; if (__comp(*__i, *__first)) &#123; typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type __val = _GLIBCXX_MOVE(*__i); _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1); *__first = _GLIBCXX_MOVE(__val); &#125; else std::__unguarded_linear_insert(__i, __comp); &#125; &#125; 1234567891011template&lt;typename _RandomAccessIterator, typename _Compare&gt; inline void __unguarded_insertion_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp) &#123; typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type_ValueType; for (_RandomAccessIterator __i = __first; __i != __last; ++__i)std::__unguarded_linear_insert(__i, __comp); &#125; 这里就不贴__unguarded_linear_insert的代码了，只需要知道其作用 其作用是找到应插入的位置并插入（无底洞啊，不建议自己查看） 而如果，当前值要插在前头，直接让其他的后移 理论上和普通插排毫无区别实际也是，但是略微对常数有所优化 那__unguarded_insertion_sort与__insertion_sort有何区别？又有什么用？ 貌似是省去了if的判断句？ 仅此而已？！ 对，仅此而已。 但是为什么可以去掉呢？ 因为这一排序是建立在最左边永远是最小值的基础上的 不仅是__unguarded_insertion_sort，事实上，所有的以__unguarded开头的函数 都不会考虑越界！ 而众所周知，比较函数是很耗时的，因此常数会有较大提升 2.2.3 效率我们从各种操作入手分析 首先，经典插排，$2N$次比较，$3N$次赋值，$N$次减法，$N$次自减。 其次，__insertion_sort 分两种情况： 每次第一分支，即if语句执行情况，$N+1$次比较，$N+1$次赋值，$3N$次自减/加（注意：此处$+1$这类常数不可忽略） 每次第二分支，即else语句执行情况，$N+1$次比较，$2N$次赋值，$N$次自减 那么假设二者出现概率相同，则平均为$N+1$次比较，$1.5N+0.5$次赋值，$2N$次自减 可以看到，少了$N-1$次比较，$1.5N-0.5$次赋值，$N$次减法，多了$N$次自减 而且，已知比较时间开销很大，赋值小一些，而减法、自检基本不耗时 而__unguarded_insertion_sort则是$N$次比较，$2N$次赋值和$N$次自减（与每次第二分支时间复杂度基本相同） 不过，在$N$很大时，$+1$的常数也会很大，这也是一直没有省略的原因 （以上复杂度请读者自行证明） 2.2.4 其他既然__unguarded_insertion_sort的时间要小得多，那么为什么不直接用呢？ 不知道读者有没有注意到2.2.2最后有一行加粗的字体 这一行字解释了为什么不能直接用__unguarded_insertion_sort排序 等等，如何保证在__insertion_sort后，全局最小值在左边呢？ 先回到__introsort_loop，它在什么情况下会返回呢？ 一是区域小于等于16（即_S_threshold），二是超过depth_limit，也就是$\log_2n$ 而由快排定义可知，左边区间的所有数据一定比右边小（也可参考图）： 所以，如果是第一种情况，就可以得出最小值在左边 如果是第二种情况，那么最左边的区间会调用堆排序，所以这段区间的最小值一定位于最左端。再加上左边区间所有的数据一定比右边小，那么最左边的数据一定是全局最小值 3.其他至此，我们完成了对sort的初步探究（仅是初步） 那么，是不是所有容器都能使用sort呢？ 并不是，主要有vector、list、数组可以使用 unordered_开头的容器只有前向迭代器，然而在1中已经说过，只有随机迭代器才能使用sort 而，map、set、priority_queue这类自带排序的当然是用不了了 而queue、stack这类则因为它们对出口和入口做了限制，无法排序 那list呢？它的迭代器是双向迭代器，也不行 不过不必担心，众所周知，list自带list::sort，虽然不能用std，但可以自己使用 万万没想到啊，一个小小的sort居然有这么多优化 不得不说，C++ STL编写者真的把编译器的效率压榨了不少，真是视效率如生命啊！ 试问：有多少人能够自己写出像STL这样好的库？ 这正是C++优点所在（并未引战） 什么？平板电视？反正平板电视也没sort 这倒是让我想起一个东西：平方根倒数速算法]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论——总论]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E6%80%BB%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[我最弱了！不接受反驳本蒟蒻决定从今天开始不定期更新算法导论，有时候想更新就更新跟天选之子一样不过还是比较高产的 但是，这就意味着，短期内我不会再更天选之子，直到我不想更新算法导论了 算法导论一周年了！（更新速度着实慢啊，以后会争取一月两篇） 下面是目录： 1——区间$DP$（更新时间：2018-8-14） 2——模拟（更新时间：2018-8-16） 3——$spfa$（更新时间：2018-8-18） 4——$Atom$（更新时间：2018-8-21） 5——$exgcd$（更新时间：2018-8-26） 6——二分（更新时间：2018-8-28） 7——$Prim$（更新时间：2018-8-29） 8——$STL$（更新时间：2018-8-30） 9——$DFS$、$BFS$（更新时间：2018-8-31） 10——背包（更新时间：2018-9-27） 11——$Dijkstra$（更新时间：2019-8-2） 12——模拟退火（$SA$）（更新时间：2019-8-14）]]></content>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论——Dijkstra]]></title>
    <url>%2F%C2%94%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94Dijkstra%2F</url>
    <content type="text"><![CDATA[各位久等了！算法导论复活了 虽说有了洛谷日报，我这也没啥用了咳咳，不说废话，直接进入主题！$Dijkstra$是单源最短路的一种算法（以下简称$Dij$），其本质是贪心，因此不能解决负边权问题（叹气） 具体思路如下： 定义变量：$s$起点，$dis[i]$表示起点到$i$的最短距离,$map[i][j]$表示边$i,j$的权值，$vis[i]$表示$i$是否被访问 将$map[i][j]$初始化为$INF$，$map[i][i]=0$ 读入，并加边 $dis[s]=0$，将$dis$更新一遍（不可到达点为$INF$） 找到距初始点最近的未访问点$t$，记录为访问 松弛（以$t$为中间点）：$dis[i]=\min(dis[i],dis[t]+map[t][i])$ 重复$n$遍步骤$5$ 输出答案即可 可以看出，$Dij$的时间复杂度是$O(n^2)$，理论上慢于$SPFA$，至于实际嘛…… 对于菊花图这类恶心的卡$SPFA$的图，$Dij$可以轻松跑过，不过对于P4779还是远远不够的！ 下面，进阶操作来了： $Dij$的堆优化！！！ 观察步骤$5$，发现查找这一点可以利用堆维护$dis$数组，每次取出堆顶即可 有同学发问了：可是这样就不能判断是否未访问了！ 不错，但我们可以不停地把堆顶访问过的删掉，直到堆顶是未访问过的 有同学又发问了：可是这样会有重复节点啊！ 很好，接下来我们需要引入一个概念：懒惰删除 这是指不删除节点，而直接跳过该节点的操作 例如：堆中有点$(1,2),(1,3),(2,3)$ 此时$dis[1]=2,dis[2]=3$ 在第二次操作时，会发现$dis[1]!=3$，那么，我们就懒惰删除，跳过它！ 至于堆的实现，可以使用$STL$的$priority$_$queue$来代替（您如果想手写堆，我也不拦着您） 注：这题不能用邻接矩阵！！！要用链式前向星（参见$SPFA$） 复杂度分析：对于每个点，删除，插入，取出操作均为$\log n$，每条边也是$\log n$，因此总复杂度为$O((n+m)\log n)$ 所以计算一下：最坏情况约为$5000000$左右，建议加个快读，不然…… 这样就能$AC P4779$了！ 代码实现： 略 参见P4779题解（个人建议第二篇）]]></content>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法导论——模拟退火]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%2F</url>
    <content type="text"><![CDATA[今天来说一个玄学算法：模拟退火！（真·玄学）先说一说它的名称来源：$Link$ 退火是一种金属热处理工艺，指的是将金属缓慢加热到一定温度，保持足够时间，然后以适宜速度冷却。…… 这貌似和$OI$毫无关系啊……，再看看模拟退火？$Link$ 模拟退火（$Simulate Anneal$，$SA$）的出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性。模拟退火算法是一种通用的优化算法，其物理退火过程由加温过程、等温过程、冷却过程这三部分组成。 这……还真有关系，而且就是思路 下面解释一下模拟退火的几个特点： 非酋不建议使用，看脸 选一个好的随机种子很重要，当然srand(time(NULL))也可以（本人使用） 日常调参（降温系数，初温，末温，次数） 如果当前值更优，则无条件将当前值作为最优解，并接受，否则以一定概率接受当前值（概率与温度有关） 一次难以出正解 欧皇除外 下面附图，便于理解： 看得出，高温时答案会不断跳动 但随着温度降低，逐渐在最优解附近稳定 （当然，正常情况下，常会误入歧途，跑到次优解去了） 步骤： 随机选一个 如果当前值更优，则无条件将当前值作为最优解，并接受，否则以一定概率接受当前值（概率与温度有关） 降温，如果温度低于末温，结束 附常用参数： 降温系数 $0.993$ ~ $0.998$ 初温 $2000$ ~ $5000$ 末温 $1e-13$ ~ $1e-17$ 次数 $3$ ~ $20$ 对于调参： 如果您脸黑没有$AC$，可以调大初温或调小末温 如果您时间充裕，也可以多跑几次或者调大降温系数 附上本人P1337[JSOI2004]平衡点/吊打XXXAC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define cold 0.997#define temperature 3000#define lastemp 1e-15#define times 3#define INF 1&lt;&lt;30using namespace std;struct node&#123; int x,y,w;&#125;a[1001];int n;double t,tx,ty,tw,ansx,ansy,anse;double energy(double x,double y)&#123; double e=0; for(int i=1;i&lt;=n;++i) &#123; tx=x-a[i].x; ty=y-a[i].y; tw=a[i].w; e+=sqrt(tx*tx+ty*ty)*tw ; &#125; return e;&#125;void SA()&#123; t=temperature; while(t&gt;lastemp) &#123; double nx=ansx+((rand()*2)-RAND_MAX)*t; double ny=ansy+((rand()*2)-RAND_MAX)*t; double ne=energy(nx,ny); if(ne&lt;anse)ansx=nx,ansy=ny,anse=ne; else if(exp((anse-ne)/t)*RAND_MAX&gt;rand())ansx=nx,ansy=ny; t*=cold; &#125;&#125;int main()&#123; srand(time(NULL)); cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].w; ansx+=a[i].x; ansy+=a[i].y; &#125; ansx/=n; ansy/=n; anse=energy(ansx,ansy); for(int i=1;i&lt;=times;++i)SA(); printf("%.3lf %.3lf",ansx,ansy); return 0;&#125; 跑得稍微有点慢，共计$1200ms$多，但都每个点不超过$400ms$，如果有巨佬有更优参数可以在评论里告诉我（该题某篇题解参数亲测不行） 一些问题与回答 $Q$：如果调参调到极限还是不能$AC$怎么办？ $A$：您太非了 试试多交几次或者换个随机种子 （随机种子例子：$19260817$，$233333$，$114514$） $Q$：怎么调参？ $A$：看心情 在保证$AC$的情况下，尽量调小一些 $Q$：如果无论如何都$AC$不了呢？ $A$：您可以去非洲了 （叹气）您还是去打正解吧 习题：P2503[HAOI2006]均分数据 （闲话：模拟退火英文名$SA$，即$Simulate Anneal$，就是模拟+退火）]]></content>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表]]></title>
    <url>%2F%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[@剑圣夜雨声烦 @林则徐左宗棠 @犇字怎么打 @AK47 @QAQ永动机 @空界_无尽 @louis_zhq @fzhfzh @流星之愿]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天选之子v1.7.2]]></title>
    <url>%2F%E5%A4%A9%E9%80%89%E4%B9%8B%E5%AD%90v1-7-2%2F</url>
    <content type="text"><![CDATA[见代码（修复了一些Bug，感谢@fzhfzh 和@gongcharlie ）&lt; !—more—&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598159916001601160216031604160516061607160816091610161116121613161416151616161716181619162016211622162316241625162616271628162916301631163216331634163516361637163816391640164116421643164416451646164716481649165016511652165316541655165616571658165916601661166216631664166516661667166816691670167116721673167416751676167716781679168016811682168316841685168616871688168916901691169216931694169516961697169816991700170117021703170417051706170717081709171017111712171317141715171617171718171917201721172217231724172517261727172817291730173117321733173417351736173717381739174017411742174317441745174617471748174917501751175217531754175517561757175817591760176117621763176417651766176717681769177017711772177317741775177617771778177917801781178217831784178517861787178817891790179117921793179417951796179717981799180018011802180318041805180618071808180918101811181218131814181518161817181818191820182118221823182418251826182718281829183018311832183318341835183618371838183918401841184218431844184518461847184818491850185118521853185418551856185718581859186018611862186318641865186618671868186918701871187218731874187518761877187818791880188118821883188418851886188718881889189018911892189318941895189618971898189919001901190219031904190519061907190819091910191119121913191419151916191719181919192019211922192319241925192619271928192919301931193219331934193519361937193819391940194119421943194419451946194719481949195019511952195319541955195619571958195919601961196219631964196519661967196819691970197119721973197419751976197719781979198019811982198319841985198619871988198919901991199219931994199519961997199819992000200120022003200420052006200720082009201020112012201320142015201620172018201920202021202220232024202520262027202820292030203120322033203420352036203720382039204020412042204320442045204620472048204920502051205220532054205520562057205820592060206120622063206420652066206720682069207020712072207320742075207620772078207920802081208220832084208520862087208820892090209120922093209420952096209720982099210021012102210321042105210621072108210921102111211221132114211521162117211821192120212121222123212421252126212721282129213021312132213321342135213621372138213921402141214221432144214521462147214821492150215121522153215421552156215721582159216021612162216321642165216621672168216921702171217221732174217521762177217821792180218121822183218421852186218721882189219021912192219321942195219621972198219922002201220222032204220522062207220822092210221122122213221422152216221722182219222022212222222322242225222622272228222922302231223222332234223522362237223822392240224122422243224422452246224722482249225022512252225322542255225622572258225922602261226222632264226522662267226822692270227122722273227422752276227722782279228022812282228322842285228622872288228922902291229222932294229522962297229822992300230123022303230423052306230723082309231023112312231323142315231623172318231923202321232223232324232523262327232823292330233123322333233423352336233723382339234023412342234323442345234623472348234923502351235223532354235523562357235823592360236123622363236423652366236723682369237023712372237323742375237623772378237923802381238223832384238523862387238823892390239123922393239423952396239723982399240024012402240324042405240624072408240924102411241224132414241524162417241824192420242124222423242424252426242724282429243024312432243324342435243624372438243924402441244224432444244524462447244824492450245124522453245424552456245724582459#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;time.h&gt;#include&lt;windows.h&gt;#include&lt;cmath&gt;#include&lt;conio.h&gt;using namespace std;typedef long long ll;#define min(a,b) (a)&lt;(b)?(a):(b)#define max(a,b) (a)&gt;(b)?(a):(b)struct player&#123; ll Attack,Defence,HP,MP,MaxHP,MaxMP,Money; ll SmallHP,MiddleHP,LargeHP,SmallMP,MiddleMP,LargeMP; ll SmallAttack,MiddleAttack,LargeAttack,SuperAttack; ll SKill1Level,SKill2Level,SKill3Level,Level,Experience; ll PetKind,PetLevel; ll Vocation,OwnSkill,OwnSkillLevel,SpeakSpeed; double SkillUp; string UserName,OwnSkillName;&#125;player1;bool life=1,ForestOpen,EatingGet,WorkOpen,Special;int LevelMost=10,Mission1Get;string MonsterName[20]=&#123;" ","小狮子","中狮子","大狮子","神圣狮子","神圣狮子王","小石怪","中石怪","大石怪","神圣石怪","神圣石怪王","混沌魔王"&#125;;int MonsterAttack[20]=&#123;0,5,10,20,50,50,10,20,50,100,200,1000&#125;;int MonsterDefence[20]=&#123;0,3,5,10,20,50,5,10,20,50,100,500&#125;;int MonsterHP[20]=&#123;0,50,100,200,500,1000,100,200,500,1000,2000,10000&#125;;string Question[10]=&#123;"66+51=","51+49=","25+96=","56+52=","21+274="&#125;;string Answer[10]=&#123;"117","100","121","108","295"&#125;;int LevelUp[50]=&#123;0,10,20,50,200,500,3000,9000,13000,19000,30000,50000,60000,70000,90000,100000,120000,140000,150000,170000,200000,220000,222222,233333,240000,250000,270000,280000,300000,350000,400000,500000,600000&#125;;string PassWord="VictoryDefeat";void Slowsay(string a)&#123; int l=a.size(); for(int i=0;i&lt;l;i++) &#123; cout&lt;&lt;a[i]; Sleep(player1.SpeakSpeed); &#125; printf("\n");&#125;void Clear()&#123; Sleep(1500); system("cls");&#125;void Start()&#123; if(MessageBox(NULL,"是否跳过剧情？","天选之子",MB_YESNO)==7) &#123; Slowsay("......"); Slowsay("......"); Slowsay("......"); system("cls"); Slowsay("少年：这......这是哪里？"); Sleep(1500); Slowsay("少年：为什么我手里握着一把剑，还穿着奇怪的铠甲？"); Slowsay("来自天边的奇怪声音：少年，这是天赐圣剑和天赐圣铠，你是被上天选中的天选之子！"); Slowsay("来自天边的奇怪声音：你的目标是解救被混沌魔王抢走的公主"); Slowsay("少年：这不就是小木剑和布衣吗？"); Sleep(1500); Slowsay("来自天边的奇怪声音：呃，其实你说对了，这就是小木剑和布衣，但它们是有等级的，到最高等级就变成了天赐圣剑和天赐圣铠了"); Clear(); Slowsay("来自天边的奇怪声音：它们一共有10级，下面介绍一下："); Slowsay("来自天边的奇怪声音：0级：小木剑和布衣"); Slowsay("来自天边的奇怪声音：1级：匕首和斗篷"); Slowsay("来自天边的奇怪声音：2级：短剑和轻铠"); Slowsay("来自天边的奇怪声音：3级：铜剑和短铠"); Slowsay("来自天边的奇怪声音：4级：铁剑和铁铠"); Slowsay("来自天边的奇怪声音：5级：长剑和长铠"); Slowsay("来自天边的奇怪声音：6级：重剑和重铠"); Slowsay("来自天边的奇怪声音：7级：巨剑和巨铠"); Slowsay("来自天边的奇怪声音：8级：剑王和铠王"); Slowsay("来自天边的奇怪声音：9级：剑圣和铠圣"); Slowsay("来自天边的奇怪声音：10级：天赐圣剑和天赐圣铠"); Clear(); Slowsay("来自天边的奇怪声音：接下来是操作方式"); Slowsay("来自天边的奇怪声音：根据提示输入数字，千万不要输入不在范围内的数，否则可能会崩溃！"); Slowsay("来自天边的奇怪声音：我会在旁边加括号的，括号里的是说明"); Clear(); Sleep(7000); &#125; Slowsay("接下来是宠物系统"); Slowsay("目前共有五只宠物：麒麟、饕餮、狻猊、狴犴、貔貅"); Slowsay("它们分别对应功能：攻击、回血、技能、防御、钱财"); Slowsay("宠物也能升级，满级30级"); Slowsay("请问你想选择哪一只：（序号从1到5）"); player1.PetKind=getch()-48; player1.PetLevel=1; Clear(); Slowsay("来自天边的奇怪声音：最后，告诉我你的名字是："); cin&gt;&gt;player1.UserName; if(player1.UserName=="VictoryDefeat") &#123; Slowsay("觉醒吧，沉睡多年的蒟蒻！"); Slowsay("神圣觉醒！！！！！！！！！！！！！！！！！！！！"); player1.Attack+=233333666; player1.Defence+=233333666; player1.HP=player1.MaxHP+=233333666; player1.MP=player1.MaxMP+=233333666; player1.PetLevel+=233333666; player1.SKill1Level=player1.SKill2Level=player1.SKill3Level=player1.OwnSkillLevel+=233333666; &#125; if(player1.UserName=="灭霸"||player1.UserName=="Thanos") &#123; Slowsay("小伙子很不错嘛，那就赐予你这个------无限手套！"); Slowsay("你已经等于无敌了"); Slowsay("好了，去征服宇宙吧！我只是超越者而已。"); player1.Attack+=233333666; player1.Defence+=233333666; player1.HP=player1.MaxHP+=233333666; player1.MP=player1.MaxMP+=233333666; player1.PetLevel+=233333666; player1.SKill1Level=player1.SKill2Level=player1.SKill3Level=player1.OwnSkillLevel+=233333666; &#125; if(player1.UserName=="Hulk"||player1.UserName=="浩克"||player1.UserName=="绿巨人") &#123; Slowsay("你好啊，布鲁斯·班纳博士"); Slowsay("很可惜，你在复联3中表现太差了"); Slowsay("这只是吐槽而已"); player1.Attack+=233333666; player1.HP=player1.MaxHP+=233333666; &#125; if(player1.UserName=="StarLord"||player1.UserName=="Quill"||player1.UserName=="星爵"||player1.UserName=="奎尔") &#123; Slowsay("你好啊，星爵"); Slowsay("你在复联3中除了一拳打醒灭霸以外都挺好的"); Slowsay("尤其是那个中指，我超喜欢的"); Slowsay("话说你怎么会喜欢卡魔拉？她可是绿的！"); Slowsay("这只是吐槽而已"); player1.Defence+=233333666; &#125; if(player1.UserName=="IronMan"||player1.UserName=="TonyStark"||player1.UserName=="钢铁侠"||player1.UserName=="托尼·斯塔克") &#123; Slowsay("你好啊，钢铁侠"); Slowsay("你和你家小辣椒接吻的时候被奇异博士看到了，尴不尴尬？"); Slowsay("你的血边战甲怎么造出来的？"); Slowsay("我也想要一个"); Slowsay("这只是吐槽而已"); player1.Attack+=233333666; player1.Defence+=233333666; player1.MP=player1.MaxMP+=233333666; &#125; if(player1.UserName=="Doctor Strange"||player1.UserName=="奇异博士") &#123; Slowsay("你好啊，奇异博士"); Slowsay("你的这些技能真是太牛逼了"); Slowsay("我常常在长跑的时候想，我要是也能开门就好了"); Slowsay("还有一个问题：你不是说在时间宝石与钢铁侠和蜘蛛侠之间选一个的话"); Slowsay("你会选时间宝石吗？那你为什么要拿时间宝石换钢铁侠的命？"); Slowsay("这只是吐槽而已"); player1.Attack+=233333666; player1.Defence+=233333666; player1.SKill1Level=player1.SKill2Level=player1.SKill3Level=player1.OwnSkillLevel+=233333666; &#125; if(player1.UserName=="Captain America"||player1.UserName=="Steven"||player1.UserName=="美国队长") &#123; Slowsay("你好啊，美国队长"); Slowsay("你本来不是一个盾的么，在复联3里咋变俩了？"); Slowsay("你是升级了么，还多了一个盾……"); Slowsay("你能空手接无限手套也是很强"); Slowsay("不过你的好基友巴基死了，太惨了……"); Slowsay("这只是吐槽而已"); player1.SKill1Level=player1.SKill2Level=player1.SKill3Level=player1.OwnSkillLevel+=233333666; player1.Attack+=233333666; player1.Defence+=233333666; &#125; if(player1.UserName=="冬日战士"||player1.UserName=="冬兵"||player1.UserName=="Winter Soidier") &#123; Slowsay("你好啊，冬兵"); Slowsay("你的手臂真是高科技，搞得小浣熊都想要了"); Slowsay("话说回来，你和黑豹的关系怎么样？"); Slowsay("应该还不错吧"); Slowsay("这只是吐槽而已"); player1.SKill1Level=player1.SKill2Level=player1.SKill3Level=player1.OwnSkillLevel+=233333666; player1.Attack+=233333666; player1.Defence+=233333666; &#125; if(player1.UserName=="Black Panther"||player1.UserName=="黑豹") &#123; Slowsay("你好啊，黑豹"); Slowsay("你的铠甲在对战灭霸的时候貌似没有任何用啊"); Slowsay("那么厉害的反弹功能居然没有用"); Slowsay("你妹妹的遥控什么的高科技除了弄出幻视的宝石（虽然失败了）");; Slowsay("以外并没有什么用啊"); Slowsay("这只是吐槽而已"); player1.SKill1Level=player1.SKill2Level=player1.SKill3Level=player1.OwnSkillLevel+=233333666; player1.Attack+=233333666; player1.Defence+=233333666; player1.MP=player1.MaxMP+=233333666; &#125; Clear(); Slowsay("其实你有四种职业可以选择："); Slowsay("一个是剑圣，一个是坦克，一个是弓箭手，一个是魔法师"); Slowsay("他们的属性和专属技能也不一样"); Slowsay("在选择职业后还可以选择专属技能"); Slowsay("你想选择的职业是：（剑圣为1，坦克为2，弓箭手为3，魔法师为4）"); player1.Vocation=getch()-48; system("cls"); if(player1.Vocation==1) &#123; Slowsay("剑圣有三种专属技能："); Slowsay("1.暴风狂击：剑圣在剑中注入飓风的力量，对对手造成巨量伤害并使对手1回合无法动弹"); Slowsay("2.剑刃风暴：剑圣不停地旋转自己的剑，对对手造成多次伤害"); Slowsay("3.飓风之力：剑圣使自己攻击大幅度提升，并且防御数倍增加"); Slowsay("其中，1，2技能为主动技能，3技能为被动技能"); Slowsay("你想选择的技能是："); player1.OwnSkill=getch()-48; player1.OwnSkillLevel=1; player1.Attack+=50; player1.Defence+=20; player1.MP=player1.MaxMP+=80; if(player1.OwnSkill==1)player1.OwnSkillName="暴风狂击"; if(player1.OwnSkill==2)player1.OwnSkillName="剑刃风暴"; if(player1.OwnSkill==3) &#123; player1.Attack*=1.1; player1.Defence*=5; &#125; &#125; if(player1.Vocation==2) &#123; Slowsay("坦克有三种专属技能："); Slowsay("1.雷霆重击：坦克使用雷霆之力砸向地面，对对手造成巨量伤害"); Slowsay("2.闪电狂怒：坦克不停地释放雷霆万钧的闪电，对对手造成多次伤害并使对手1回合无法动弹"); Slowsay("3.闪电突袭：坦克在一次攻击中能发动两次攻击，但攻击力会略微下降"); Slowsay("其中，1，2技能为主动技能，3技能为被动技能"); Slowsay("你想选择的技能是："); player1.OwnSkill=getch()-48; player1.OwnSkillLevel=1; player1.Attack+=30; player1.Defence+=50; player1.HP=player1.MaxHP+=100; if(player1.OwnSkill==1)player1.OwnSkillName="雷霆重击"; if(player1.OwnSkill==2)player1.OwnSkillName="闪电狂怒"; if(player1.OwnSkill==3)player1.Attack*=1.8; &#125; if(player1.Vocation==3) &#123; Slowsay("弓箭手有三种专属技能："); Slowsay("1.尖锐利箭：弓箭手射出一支尖锐的箭，对对手造成巨量伤害，使对手流血2回合"); Slowsay("2.多发神箭：弓箭手射出数支箭，对对手造成多次伤害"); Slowsay("3.天生敏捷：弓箭手的防御出奇的高"); player1.OwnSkill=getch()-48; player1.OwnSkillLevel=1; player1.Attack+=40; player1.Defence+=20; player1.HP=player1.MaxHP+=10; player1.MP=player1.MaxMP+=10; if(player1.OwnSkill==1)player1.OwnSkillName="尖锐利箭"; if(player1.OwnSkill==2)player1.OwnSkillName="多发神箭"; if(player1.OwnSkill==3)player1.Defence*=3.1; &#125; if(player1.Vocation==4) &#123; Slowsay("此职业为测试职业，请谨慎食用"); Slowsay("1.火焰流星：使对手3回合着火，并造成巨量伤害"); Slowsay("2.无限闪电：使对手1回合不能动，并造成多次伤害"); Slowsay("3.奥秘之术：法术攻击很高"); player1.OwnSkill=getch()-48; player1.OwnSkillLevel=1; player1.SkillUp=0.1; player1.HP=player1.MaxHP+=10; player1.MP=player1.MaxMP+=50; player1.Attack+=20; if(player1.OwnSkill==1)player1.OwnSkillName="火焰流星"; if(player1.OwnSkill==2)player1.OwnSkillName="无限闪电"; if(player1.OwnSkill==3)player1.SkillUp+=0.15; &#125; if(player1.Vocation==9) &#123; Slowsay("小伙子很牛逼啊，如果你能通过我的考验，我就让你变得很强"); Slowsay("请说出灭霸获取无限宝石的顺序及其地点（从早到晚）："); Slowsay("（注：说“xx”即可，无需说“xx宝石”，格式为“a-&gt;b-&gt;c”）"); string zz,zzz; cin&gt;&gt;zz&gt;&gt;zzz; if(zz=="力量-&gt;空间-&gt;现实-&gt;灵魂-&gt;时间-&gt;心灵"&amp;&amp;zzz=="山达尔星-&gt;雷神的飞船上-&gt;虚无知地-&gt;沃密尔星-&gt;泰坦星-&gt;地球") &#123; Slowsay("小伙子很不错嘛，那就赐予你这个------无限手套！"); Slowsay("你已经等于无敌了"); Slowsay("好了，去征服宇宙吧！我只是超越者而已。"); player1.Attack+=233333666; player1.Defence+=233333666; player1.HP=player1.MaxHP+=233333666; player1.MP=player1.MaxMP+=233333666; player1.PetLevel+=233333666; &#125; &#125; Clear();&#125;void Read()&#123; freopen("TXZZ.data","r",stdin); cin&gt;&gt;player1.UserName; cin&gt;&gt;player1.Attack&gt;&gt;player1.Defence; cin&gt;&gt;player1.HP&gt;&gt;player1.MaxHP&gt;&gt;player1.MP&gt;&gt;player1.MaxMP; cin&gt;&gt;player1.Level&gt;&gt;player1.Experience; cin&gt;&gt;player1.SKill1Level&gt;&gt;player1.SKill2Level&gt;&gt;player1.SKill3Level; cin&gt;&gt;player1.SmallHP&gt;&gt;player1.MiddleHP&gt;&gt;player1.LargeHP; cin&gt;&gt;player1.SmallMP&gt;&gt;player1.MiddleMP&gt;&gt;player1.LargeMP; cin&gt;&gt;player1.SmallAttack&gt;&gt;player1.MiddleAttack&gt;&gt;player1.LargeAttack&gt;&gt;player1.SuperAttack; cin&gt;&gt;player1.Money; cin&gt;&gt;Mission1Get; cin&gt;&gt;ForestOpen; cin&gt;&gt;EatingGet; cin&gt;&gt;Special; cin&gt;&gt;LevelMost; cin&gt;&gt;player1.PetKind; cin&gt;&gt;player1.PetLevel; cin&gt;&gt;player1.Vocation; cin&gt;&gt;player1.OwnSkill; cin&gt;&gt;player1.OwnSkillLevel; fclose(stdin); freopen("CON","r",stdin);&#125;void Save()&#123; freopen("TXZZ.data","w",stdout); cout&lt;&lt;player1.UserName&lt;&lt;endl; cout&lt;&lt;player1.Attack&lt;&lt;endl; cout&lt;&lt;player1.Defence&lt;&lt;endl; cout&lt;&lt;player1.HP&lt;&lt;endl; cout&lt;&lt;player1.MaxHP&lt;&lt;endl; cout&lt;&lt;player1.MP&lt;&lt;endl; cout&lt;&lt;player1.MaxMP&lt;&lt;endl; cout&lt;&lt;player1.Level&lt;&lt;endl; cout&lt;&lt;player1.Experience&lt;&lt;endl; cout&lt;&lt;player1.SKill1Level&lt;&lt;endl; cout&lt;&lt;player1.SKill2Level&lt;&lt;endl; cout&lt;&lt;player1.SKill3Level&lt;&lt;endl; cout&lt;&lt;player1.SmallHP&lt;&lt;endl; cout&lt;&lt;player1.MiddleHP&lt;&lt;endl; cout&lt;&lt;player1.LargeHP&lt;&lt;endl; cout&lt;&lt;player1.SmallMP&lt;&lt;endl; cout&lt;&lt;player1.MiddleMP&lt;&lt;endl; cout&lt;&lt;player1.LargeMP&lt;&lt;endl; cout&lt;&lt;player1.SmallAttack&lt;&lt;endl; cout&lt;&lt;player1.MiddleAttack&lt;&lt;endl; cout&lt;&lt;player1.LargeAttack&lt;&lt;endl; cout&lt;&lt;player1.SuperAttack&lt;&lt;endl; cout&lt;&lt;player1.Money&lt;&lt;endl; cout&lt;&lt;Mission1Get&lt;&lt;endl; cout&lt;&lt;ForestOpen&lt;&lt;endl; cout&lt;&lt;EatingGet&lt;&lt;endl; cout&lt;&lt;Special&lt;&lt;endl; cout&lt;&lt;LevelMost&lt;&lt;endl; cout&lt;&lt;player1.PetKind&lt;&lt;endl; cout&lt;&lt;player1.PetLevel&lt;&lt;endl; cout&lt;&lt;player1.Vocation&lt;&lt;endl; cout&lt;&lt;player1.OwnSkill&lt;&lt;endl; cout&lt;&lt;player1.OwnSkillLevel&lt;&lt;endl; fclose(stdout);&#125;void say(string a)&#123; int l=a.size(); for(int i=0;i&lt;l;i++) &#123; cout&lt;&lt;a[i]; Sleep(player1.SpeakSpeed); &#125;&#125;bool CanUse(int i)&#123; if(i==1&amp;&amp;player1.SmallHP)return 1; if(i==2&amp;&amp;player1.MiddleHP)return 1; if(i==3&amp;&amp;player1.LargeHP)return 1; if(i==4&amp;&amp;player1.SmallMP)return 1; if(i==5&amp;&amp;player1.MiddleMP)return 1; if(i==6&amp;&amp;player1.LargeMP)return 1; if(i==7&amp;&amp;player1.SmallAttack)return 1; if(i==8&amp;&amp;player1.MiddleAttack)return 1; if(i==9&amp;&amp;player1.LargeAttack)return 1; if(i==10&amp;&amp;player1.SuperAttack)return 1; return 0;&#125;void Use(int i)&#123; if(i==1) &#123; say("成功使用小血瓶，血量增加10点"); printf("\n"); player1.HP=min(player1.HP+10,player1.MaxHP); player1.SmallHP--; &#125; if(i==2) &#123; say("成功使用中血瓶，血量增加20点"); printf("\n"); player1.HP=min(player1.HP+20,player1.MaxHP); player1.MiddleHP--; &#125; if(i==3) &#123; say("成功使用大血瓶，血量增加50点"); printf("\n"); player1.HP=min(player1.HP+50,player1.MaxHP); player1.LargeHP--; &#125; if(i==4) &#123; say("成功使用小魔瓶，魔法值增加10点"); printf("\n"); player1.MP=min(player1.MP+10,player1.MaxMP); player1.SmallMP--; &#125; if(i==5) &#123; say("成功使用中魔瓶，魔法值增加20点"); printf("\n"); player1.MP=min(player1.MP+20,player1.MaxMP); player1.MiddleMP--; &#125; if(i==6) &#123; say("成功使用大魔瓶，魔法值增加50点"); printf("\n"); player1.MP=min(player1.MP+50,player1.MaxMP); player1.LargeMP--; &#125;&#125;bool LastMonster()&#123; Clear(); int HP=10000; int Attack=1000; int Defence=500; int burn=0,stop=0,blood=0; if(player1.PetKind==4) &#123; say("你的宠物狴犴使对方攻击降低"); printf("%lld",min(player1.PetLevel*10,Attack)); Slowsay("点攻击"); Attack-=player1.PetLevel*8; &#125; while(HP&gt;0&amp;&amp;player1.HP&gt;0) &#123; Clear(); Slowsay("请输入你想执行的操作："); Slowsay("1：攻击 2：使用技能 3：使用道具"); int x,End=1; x=getch()-48; if(x&lt;0||x&gt;3)continue; if(x==1) &#123; if(player1.Attack&lt;Defence) &#123; say("攻击小于对手防御，建议逃跑或使用道具"); printf("\n"); &#125; else &#123; int t=min(HP,player1.Attack-Defence); HP-=t; say("对敌人造成");printf("%d",t);say("点伤害"); &#125; &#125; if(x==2) &#123; say("请输入想要使用的技能编号:(1为火球术,2为雷暴术,3为治疗术,4为专属技能)"); printf("\n"); int y; y=getch()-48; if(y==1&amp;&amp;!player1.SKill1Level) &#123; say("火球术尚未学习！"); printf("\n"); End=0; &#125; if(y==2&amp;&amp;!player1.SKill2Level) &#123; say("雷暴术尚未学习！"); printf("\n"); End=0; &#125; if(y==3&amp;&amp;!player1.SKill3Level) &#123; say("治疗术尚未学习！"); printf("\n"); End=0; &#125; if(y==1&amp;&amp;player1.SKill1Level) &#123; if(player1.MP&lt;3) &#123; say("魔法值不足，使用失败"); printf("\n"); End=0; &#125; else &#123; say("使用火球术，对敌人造成");printf("%lld",5*player1.SKill1Level*int(player1.SkillUp+1));say("点伤害"); printf("\n"); say("消耗3点魔法值"); printf("\n"); HP-=5*player1.SKill1Level*int(player1.SkillUp+1); player1.MP-=3; &#125; &#125; if(y==2&amp;&amp;player1.SKill2Level) &#123; if(player1.MP&lt;5) &#123; say("魔法值不足，使用失败"); printf("\n"); End=0; &#125; else &#123; say("使用雷暴术，对敌人造成");printf("%lld",10*player1.SKill2Level*int(player1.SkillUp+1));say("点伤害"); printf("\n"); say("消耗5点魔法值"); printf("\n"); HP-=10*player1.SKill2Level*int(player1.SkillUp+1); player1.MP-=5; &#125; &#125; if(y==3&amp;&amp;player1.SKill3Level) &#123; if(player1.MP&lt;10) &#123; say("魔法值不足，使用失败"); printf("\n"); End=0; &#125; else &#123; say("使用治疗术，回复");printf("%lld",15*player1.SKill3Level*int(player1.SkillUp+1));say("点血量"); printf("\n"); say("消耗10点魔法值"); printf("\n"); player1.HP=min(player1.MaxHP,player1.HP+15*player1.SKill3Level*int(player1.SkillUp+1)); player1.MP-=10; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==1&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;20) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) &#123; HP-=player1.OwnSkillLevel*50; stop=1; &#125; if(player1.OwnSkill==2) HP-=player1.OwnSkillLevel*(player1.Attack-Defence); player1.MP-=20; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==2&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;20) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) HP-=player1.OwnSkillLevel*50; if(player1.OwnSkill==2) &#123; HP-=player1.OwnSkillLevel*(player1.Attack-Defence); stop=1; &#125; player1.MP-=20; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==3&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;20) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) &#123; HP-=player1.OwnSkillLevel*50; blood=2; &#125; if(player1.OwnSkill==2) HP-=player1.OwnSkillLevel*(player1.Attack-Defence); player1.MP-=20; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==4&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;30) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) &#123; HP-=player1.OwnSkillLevel*45; burn=3; &#125; if(player1.OwnSkill==2) &#123; HP-=player1.OwnSkillLevel*(player1.Attack-Defence); stop=1; &#125; player1.MP-=30; &#125; &#125; &#125; if(x==3) &#123; say("请输入想要使用的道具编号，想查询道具的编号请输入*"); printf("\n"); int y; y=getch(); if(y=='*') &#123; say("1：小血瓶"); printf("\n"); say("2：中血瓶"); printf("\n"); say("3：大血瓶"); printf("\n"); say("4：小魔瓶"); printf("\n"); say("5：中魔瓶"); printf("\n"); say("6：大魔瓶"); printf("\n"); say("7：小炸弹"); printf("\n"); say("8：中炸弹"); printf("\n"); say("9：大炸弹"); printf("\n"); say("10：原子弹"); printf("\n"); End=0; &#125; else if(CanUse(y)&amp;&amp;y&lt;='6')Use(y); else if(CanUse(y)&amp;&amp;y&gt;'6') &#123; if(y=='7') &#123; Slowsay("成功使用小炸弹，对敌人造成50点伤害"); HP-=50; player1.SmallAttack--; &#125; if(y=='8') &#123; Slowsay("成功使用中炸弹，对敌人造成100点伤害"); HP-=100; player1.MiddleAttack--; &#125; if(y=='9') &#123; Slowsay("成功使用大炸弹，对敌人造成200点伤害"); HP-=200; player1.LargeAttack--; &#125; if(y=='0') &#123; Slowsay("成功使用原子弹，对敌人造成500点伤害"); HP-=500; player1.SuperAttack--; &#125; &#125; else &#123; say("道具不足，无法使用"); printf("\n"); End=0; &#125; &#125; if(End) &#123; if(player1.PetKind==1) &#123; say("你的宠物麒麟对灭世魔王造成了"); printf("%lld",min(20*player1.PetLevel,HP)); Slowsay("点伤害"); HP-=min(20*player1.PetLevel,HP); &#125; if(player1.PetKind==3) &#123; say("你的宠物狻猊对灭世魔王造成了"); printf("%lld",min(15*player1.PetLevel+100,HP)); Slowsay("点伤害"); HP-=min(15*player1.PetLevel+100,HP); &#125; if(player1.PetKind==2) &#123; say("你的宠物饕餮给你回了"); printf("%lld",player1.PetLevel*10); Slowsay("点血"); player1.HP+=player1.PetLevel*10; &#125; if(!stop) &#123; player1.HP-=Attack-player1.Defence&lt;0?0:Attack-player1.Defence; say("灭世魔王对你造成了");printf("%lld",Attack-player1.Defence&lt;0?0:Attack-player1.Defence);say("点伤害"); printf("\n"); &#125; if(stop) &#123; stop=0; Slowsay("灭世魔王被你定住，无法攻击"); &#125; if(blood) &#123; --blood; HP-=40; Slowsay("灭世魔王受到了40点流血伤害"); &#125; if(burn) &#123; --burn; HP-=30; Slowsay("灭世魔王受到了30点灼烧伤害"); &#125; &#125; &#125; Sleep(7000); if(player1.HP&lt;=0)return 0; else return 1;&#125;void Level()&#123; int EXP=player1.Experience,LV=player1.Level; while(EXP&gt;=LevelUp[LV+1]&amp;&amp;LV&lt;=LevelMost) &#123; LV++; EXP-=LevelUp[LV]; player1.Attack+=100; player1.Defence+=100; player1.MaxHP+=500; player1.HP=player1.MaxHP; player1.MaxMP+=500; player1.MP=player1.MaxMP; player1.Money+=500; &#125; if(LV&gt;=5)WorkOpen=1; if(player1.Level==LV)Slowsay("升级失败，经验不足"); else &#123; say("升级成功，升了");printf("%lld",LV-player1.Level);Slowsay("级"); &#125; player1.Experience=EXP; player1.Level=LV;&#125;void Story2()&#123; Slowsay("少年又一次战胜了魔王，解救了公主"); Slowsay("但是，这一次真的是大结局吗？"); Slowsay("灭世魔王死后，从天而降，出现了两个人，他们浑身散发着耀眼的光芒"); Slowsay("少年向他们跑去，他们就落了下来"); Slowsay("他们一看就非常的厉害，少年于是问道：“您二位是从何而来？”"); Slowsay("二人相视一笑，说：“我们这里有两首诗，你能看破玄机，我们就告诉你”"); Slowsay("第一首：孔丘圣人于我后，"); Slowsay(" 雀雀飞升脱凡尘。"); Slowsay(" 明亮光芒照万物，"); Slowsay(" 王临天下第一人。"); Slowsay("第二首：接凡渡尘非常人，"); Slowsay(" 引得世人入轮回。"); Slowsay(" 道行天下任我游，"); Slowsay(" 人间沧桑皆看破。"); Slowsay("少年仔细想了一想，说：你们不就是《封神演义》里的孔雀明王和接引道人吗？"); Slowsay("二人说：“不错，少年你很有天资，希望你以后能继续在惩恶扬善的道路上走下去，永不结束！！！”"); Slowsay("少年说：“谢谢二位！我以后会继续努力的！”"); Slowsay("剧情暂时告一段落，以后也不怎么会再更剧情了"); if(MessageBox(NULL,"你愿意继续惩恶扬善吗？","天选之子",MB_YESNO)==6) &#123; player1.Experience+=2000; Level(); Slowsay("很好，你要继续啊，祝愿你早日成功！"); &#125; Slowsay("敬请期待天选之子v1.6");&#125;void TheEnd()&#123; LevelMost+=10; Clear(); Slowsay("我们的天选之子成功打败了混沌魔王，解救了公主"); Slowsay("然而，公主却告诉他在混沌魔王之上，还有更厉害的魔王在等着他"); Slowsay("但是，他无所畏惧，能够去打败更为强大的魔王！"); Slowsay("就在这时，一个怪物出现了，它身上居然也穿着天赐圣剑和天赐圣铠！"); Slowsay("少年为此所震惊，怪物却告诉他，他就是过去的它，它就是未来的他！"); Slowsay("少年不相信，与怪物打了起来，但怪物实在太厉害，少年打不过它，少年落荒而逃"); Slowsay("怪物又俘虏了公主，少年即将颓废，但是眼前忽然出现一个人！"); Slowsay("他对少年说：“少年，你还记得我吗？”"); Slowsay("少年仔细一想，说：“你是那个奇怪的声音！”"); Slowsay("他说：“没错，就是我，其实世上的天选之子一共有过三个”"); Slowsay("少年说：“怎么会有三个天选之子？！”"); Slowsay("他说：“第一个是我，第二个是刚刚那个怪物，第三个是你”"); Slowsay("他说：“其实，你所掌握的力量只是皮毛，看好了！”"); Slowsay("突然，他的身上长出了一双无比华丽的翅膀"); Slowsay("少年被此所惊到，他说：“天选之子的力量是无比强大的，但是怎么运用就看你了”"); Slowsay("他说：“天选之子的力量既可以创造世界，也可以毁灭世界”"); Slowsay("他说：“你的力量也有这么强大，不信你试试”"); Slowsay("少年心中想着翅膀，身上便长出了翅膀！"); Slowsay("他说：“你想什么，你就会拥有什么”"); Slowsay("他说：“你可别想歪了啊！”"); Slowsay("他说：“你可以获取所有你能想到的装备、东西、能力”"); Slowsay("他说：“但是，为了防止你想歪，我只能送你一样能力”"); Slowsay("他说：“那就是，无限正义，不要问我它有什么用，其实我也不知道”"); Slowsay("他说：“好了，少年，去战胜怪物吧”"); Slowsay("他说：“对了，怪物的名字叫做灭世魔王”"); player1.Attack*=2; player1.Defence*=2; player1.HP=player1.MaxHP*=2; player1.MP=player1.MaxMP*=2; if(LastMonster())Story2(); Slowsay("未完待续......");&#125;void Die()&#123; Clear(); Slowsay("不...我还不能死...我还没有打败混沌魔王..."); Slowsay("我要复活！！！！！！！！"); Sleep(10000); Slowsay("复活成功"); player1.HP=player1.MaxHP;&#125;int Fight(int i)&#123; Clear(); srand((int)time(0)); string Name=MonsterName[i]; say("遭遇了");say(Name);say("！"); printf("\n"); int HP=MonsterHP[i]; int Attack=MonsterAttack[i]; int Defence=MonsterDefence[i]; int burn=0,stop=0,blood=0; if(player1.PetKind==4) &#123; say("你的宠物狴犴使对方攻击降低"); printf("%lld",min(player1.PetLevel*10,HP)); Slowsay("点攻击"); Attack-=player1.PetLevel*8; &#125; while(HP&gt;0&amp;&amp;player1.HP&gt;0) &#123; Clear(); say("请输入你想执行的操作："); printf("\n"); say("1：攻击 2：使用技能 3：使用道具 4：逃跑"); printf("\n"); int x,End=1; x=getch()-48; if(x&lt;0||x&gt;4)continue; if(x==4) &#123; say("逃跑成功，战斗失败"); printf("\n"); break; return -1; &#125; if(x==1) &#123; if(player1.Attack&lt;Defence) &#123; say("攻击小于对手防御，建议逃跑或使用道具"); printf("\n"); &#125; else &#123; int t=min(HP,player1.Attack-Defence); HP-=t; say("对敌人造成");printf("%d",t);say("点伤害"); &#125; &#125; if(x==2) &#123; say("请输入想要使用的技能编号:(1为火球术,2为雷暴术,3为治疗术,4为专属技能)"); printf("\n"); int y; y=getch()-48; if(y==1&amp;&amp;!player1.SKill1Level) &#123; say("火球术尚未学习！"); printf("\n"); End=0; &#125; if(y==2&amp;&amp;!player1.SKill2Level) &#123; say("雷暴术尚未学习！"); printf("\n"); End=0; &#125; if(y==3&amp;&amp;!player1.SKill3Level) &#123; say("治疗术尚未学习！"); printf("\n"); End=0; &#125; if(y==1&amp;&amp;player1.SKill1Level) &#123; if(player1.MP&lt;3) &#123; say("魔法值不足，使用失败"); printf("\n"); End=0; &#125; else &#123; say("使用火球术，对敌人造成");printf("%lld",5*player1.SKill1Level*int(player1.SkillUp+1));say("点伤害"); printf("\n"); say("消耗3点魔法值"); printf("\n"); HP-=5*player1.SKill1Level*int(player1.SkillUp+1); player1.MP-=3; &#125; &#125; if(y==2&amp;&amp;player1.SKill2Level) &#123; if(player1.MP&lt;5) &#123; say("魔法值不足，使用失败"); printf("\n"); End=0; &#125; else &#123; say("使用雷暴术，对敌人造成");printf("%lld",10*player1.SKill2Level*int(player1.SkillUp+1));say("点伤害"); printf("\n"); say("消耗5点魔法值"); printf("\n"); HP-=10*player1.SKill2Level*int(player1.SkillUp+1); player1.MP-=5; &#125; &#125; if(y==3&amp;&amp;player1.SKill3Level) &#123; if(player1.MP&lt;10) &#123; say("魔法值不足，使用失败"); printf("\n"); End=0; &#125; else &#123; say("使用治疗术，回复");printf("%lld",15*player1.SKill3Level*int(player1.SkillUp+1));say("点血量"); printf("\n"); say("消耗10点魔法值"); printf("\n"); player1.HP=min(player1.MaxHP,player1.HP+15*player1.SKill3Level); player1.MP-=10; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==1&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;20) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) &#123; HP-=player1.OwnSkillLevel*50; stop=1; &#125; if(player1.OwnSkill==2) HP-=player1.OwnSkillLevel*(player1.Attack-Defence); player1.MP-=20; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==2&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;20) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) HP-=player1.OwnSkillLevel*50; if(player1.OwnSkill==2) &#123; HP-=player1.OwnSkillLevel*(player1.Attack-Defence); stop=1; &#125; player1.MP-=20; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==3&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;20) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) &#123; HP-=player1.OwnSkillLevel*50; blood=2; &#125; if(player1.OwnSkill==2) HP-=player1.OwnSkillLevel*(player1.Attack-Defence); player1.MP-=20; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==4&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;30) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) &#123; HP-=player1.OwnSkillLevel*45; burn=3; &#125; if(player1.OwnSkill==2) &#123; HP-=player1.OwnSkillLevel*(player1.Attack-Defence); stop=1; &#125; player1.MP-=30; &#125; &#125; &#125; if(x==3) &#123; say("请输入想要使用的道具编号，想查询道具的编号请输入*"); printf("\n"); int y; y=getch()-48; if(y+48=='*') &#123; say("1：小血瓶"); printf("\n"); say("2：中血瓶"); printf("\n"); say("3：大血瓶"); printf("\n"); say("4：小魔瓶"); printf("\n"); say("5：中魔瓶"); printf("\n"); say("6：大魔瓶"); printf("\n"); say("7：小炸弹"); printf("\n"); say("8：中炸弹"); printf("\n"); say("9：大炸弹"); printf("\n"); say("10：原子弹"); printf("\n"); End=0; &#125; else if(CanUse(y)&amp;&amp;y&lt;=6)Use(y); else if(CanUse(y)&amp;&amp;y&gt;6) &#123; if(y==7) &#123; Slowsay("成功使用小炸弹，对敌人造成50点伤害"); HP-=50; player1.SmallAttack--; &#125; if(y==8) &#123; Slowsay("成功使用中炸弹，对敌人造成100点伤害"); HP-=100; player1.MiddleAttack--; &#125; if(y==9) &#123; Slowsay("成功使用大炸弹，对敌人造成200点伤害"); HP-=200; player1.LargeAttack--; &#125; if(y==10) &#123; Slowsay("成功使用原子弹，对敌人造成500点伤害"); HP-=500; player1.SuperAttack--; &#125; &#125; else &#123; say("道具不足，无法使用"); printf("\n"); End=0; &#125; &#125; if(End) &#123; if(player1.PetKind==1) &#123; say("你的宠物麒麟对");say(Name);say("造成了"); printf("%lld",min(20*player1.PetLevel,HP)); Slowsay("点伤害"); HP-=min(20*player1.PetLevel,HP); &#125; if(player1.PetKind==3) &#123; say("你的宠物狻猊对");say(Name);say("造成了"); printf("%lld",min(15*player1.PetLevel+100,HP)); Slowsay("点伤害"); HP-=min(15*player1.PetLevel+100,HP); &#125; if(player1.PetKind==2) &#123; say("你的宠物饕餮给你回了"); printf("%lld",player1.PetLevel*10); Slowsay("点血"); player1.HP+=player1.PetLevel*10; &#125; if(!stop) &#123; player1.HP-=Attack-player1.Defence&lt;0?0:Attack-player1.Defence; say(Name);say("对你造成了");printf("%lld",Attack-player1.Defence&lt;0?0:Attack-player1.Defence);say("点伤害"); printf("\n"); &#125; if(stop) &#123; stop=0; say(Name);Slowsay("被你定住，无法攻击"); &#125; if(blood) &#123; --blood; HP-=40; say(Name);Slowsay("受到了40点流血伤害"); &#125; if(burn) &#123; --burn; HP-=30; say(Name);Slowsay("受到了30点灼烧伤害"); &#125; &#125; &#125; Sleep(7000); if(player1.HP&lt;=0)&#123;Die();return 0;&#125; else &#123; say("战斗胜利！获得"); int XP=rand(); printf("%d",XP); Slowsay("点经验"); player1.Experience+=XP; if(player1.PetKind==5) &#123; say("你的宠物貔貅给你带来了"); printf("%lld",player1.PetLevel*20); Slowsay("元"); &#125; return 1; &#125;&#125;void LastFight()&#123; Clear(); Slowsay("混沌魔王：没错，我就是传说中的混沌魔王！"); Slowsay("混沌魔王：哈哈哈哈哈哈哈哈哈哈哈哈！！！！！！"); Slowsay("混沌魔王：你就是天选之子吗？哈哈！太弱了！"); Slowsay("混沌魔王：就凭你还想战胜我，救出公主？哼哼！想得美！"); if(player1.Level&lt;10) &#123; Slowsay("少年：我要消灭你，进化吧！"); Slowsay("混沌魔王：这...这怎么可能？！"); Slowsay("少年：看着吧，这就是传说中的天赐圣剑和天赐圣铠！"); player1.Experience=6666666; Level(); Slowsay("混沌魔王：那你也不能战胜我！我已经封锁了你的退路！"); &#125; int HP=MonsterHP[11]; int Attack=MonsterAttack[11]; int Defence=MonsterDefence[11]; int burn=0,stop=0,blood=0; if(player1.PetKind==4) &#123; say("你的宠物狴犴使对方攻击降低"); printf("%lld",min(player1.PetLevel*10,HP)); Slowsay("点攻击"); Attack-=player1.PetLevel*8; &#125; while(HP&gt;0&amp;&amp;player1.HP&gt;0) &#123; Clear(); Slowsay("请输入你想执行的操作："); Slowsay("1：攻击 2：使用技能 3：使用道具"); int x,End=1; x=getch()-48; if(x&lt;0||x&gt;3)continue; if(x==1) &#123; if(player1.Attack&lt;Defence) &#123; say("攻击小于对手防御，建议逃跑或使用道具"); printf("\n"); &#125; else &#123; int t=min(HP,player1.Attack-Defence); HP-=t; say("对敌人造成");printf("%d",t);say("点伤害"); &#125; &#125; if(x==2) &#123; say("请输入想要使用的技能编号:(1为火球术,2为雷暴术,3为治疗术,4为专属技能)"); printf("\n"); int y; y=getch()-48; if(y==1&amp;&amp;!player1.SKill1Level) &#123; say("火球术尚未学习！"); printf("\n"); End=0; &#125; if(y==2&amp;&amp;!player1.SKill2Level) &#123; say("雷暴术尚未学习！"); printf("\n"); End=0; &#125; if(y==3&amp;&amp;!player1.SKill3Level) &#123; say("治疗术尚未学习！"); printf("\n"); End=0; &#125; if(y==1&amp;&amp;player1.SKill1Level) &#123; if(player1.MP&lt;3) &#123; say("魔法值不足，使用失败"); printf("\n"); End=0; &#125; else &#123; say("使用火球术，对敌人造成");printf("%lld",5*player1.SKill1Level*int(player1.SkillUp+1));say("点伤害"); printf("\n"); say("消耗3点魔法值"); printf("\n"); HP-=5*player1.SKill1Level*int(player1.SkillUp+1); player1.MP-=3; &#125; &#125; if(y==2&amp;&amp;player1.SKill2Level) &#123; if(player1.MP&lt;5) &#123; say("魔法值不足，使用失败"); printf("\n"); End=0; &#125; else &#123; say("使用雷暴术，对敌人造成");printf("%lld",10*player1.SKill2Level*int(player1.SkillUp+1));say("点伤害"); printf("\n"); say("消耗5点魔法值"); printf("\n"); HP-=10*player1.SKill2Level*int(player1.SkillUp+1); player1.MP-=5; &#125; &#125; if(y==3&amp;&amp;player1.SKill3Level) &#123; if(player1.MP&lt;10) &#123; say("魔法值不足，使用失败"); printf("\n"); End=0; &#125; else &#123; say("使用治疗术，回复");printf("%lld",15*player1.SKill3Level*int(player1.SkillUp+1));say("点血量"); printf("\n"); say("消耗10点魔法值"); printf("\n"); player1.HP=min(player1.MaxHP,player1.HP+15*player1.SKill3Level*int(player1.SkillUp+1)); player1.MP-=10; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==1&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;20) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) &#123; HP-=player1.OwnSkillLevel*50; stop=1; &#125; if(player1.OwnSkill==2) HP-=player1.OwnSkillLevel*(player1.Attack-Defence); player1.MP-=20; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==2&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;20) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) HP-=player1.OwnSkillLevel*50; if(player1.OwnSkill==2) &#123; HP-=player1.OwnSkillLevel*(player1.Attack-Defence); stop=1; &#125; player1.MP-=20; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==3&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;20) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) &#123; HP-=player1.OwnSkillLevel*50; blood=2; &#125; if(player1.OwnSkill==2) HP-=player1.OwnSkillLevel*(player1.Attack-Defence); player1.MP-=20; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==4&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;30) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) &#123; HP-=player1.OwnSkillLevel*45; burn=3; &#125; if(player1.OwnSkill==2) &#123; HP-=player1.OwnSkillLevel*(player1.Attack-Defence); stop=1; &#125; player1.MP-=30; &#125; &#125; &#125; if(x==3) &#123; say("请输入想要使用的道具编号，想查询道具的编号请输入*"); printf("\n"); int y; y=getch()-48; if(y+48=='*') &#123; say("1：小血瓶"); printf("\n"); say("2：中血瓶"); printf("\n"); say("3：大血瓶"); printf("\n"); say("4：小魔瓶"); printf("\n"); say("5：中魔瓶"); printf("\n"); say("6：大魔瓶"); printf("\n"); say("7：小炸弹"); printf("\n"); say("8：中炸弹"); printf("\n"); say("9：大炸弹"); printf("\n"); say("10：原子弹"); printf("\n"); End=0; &#125; else if(CanUse(y)&amp;&amp;y&lt;=6)Use(y); else if(CanUse(y)&amp;&amp;y&gt;6) &#123; if(y==7) &#123; Slowsay("成功使用小炸弹，对敌人造成50点伤害"); HP-=50; player1.SmallAttack--; &#125; if(y==8) &#123; Slowsay("成功使用中炸弹，对敌人造成100点伤害"); HP-=100; player1.MiddleAttack--; &#125; if(y==9) &#123; Slowsay("成功使用大炸弹，对敌人造成200点伤害"); HP-=200; player1.LargeAttack--; &#125; if(y==10) &#123; Slowsay("成功使用原子弹，对敌人造成500点伤害"); HP-=500; player1.SuperAttack--; &#125; &#125; else &#123; say("道具不足，无法使用"); printf("\n"); End=0; &#125; &#125; if(End) &#123; if(player1.PetKind==1) &#123; say("你的宠物麒麟对混沌魔王造成了"); printf("%lld",min(20*player1.PetLevel,HP)); Slowsay("点伤害"); HP-=min(20*player1.PetLevel,HP); &#125; if(player1.PetKind==3) &#123; say("你的宠物狻猊对混沌魔王造成了"); printf("%lld",min(15*player1.PetLevel+100,HP)); Slowsay("点伤害"); HP-=min(15*player1.PetLevel+100,HP); &#125; if(player1.PetKind==2) &#123; say("你的宠物饕餮给你回了"); printf("%lld",player1.PetLevel*10); Slowsay("点血"); player1.HP+=player1.PetLevel*10; &#125; if(!stop) &#123; player1.HP-=Attack-player1.Defence&lt;0?0:Attack-player1.Defence; say("混沌魔王对你造成了");printf("%lld",Attack-player1.Defence&lt;0?0:Attack-player1.Defence);say("点伤害"); printf("\n"); &#125; if(stop) &#123; stop=0; Slowsay("混沌魔王被你定住，无法攻击"); &#125; if(blood) &#123; --blood; HP-=40; Slowsay("混沌魔王受到了40点流血伤害"); &#125; if(burn) &#123; --burn; HP-=30; Slowsay("混沌魔王受到了30点灼烧伤害"); &#125; &#125; &#125; Sleep(7000); if(player1.HP&lt;=0)Die(); else TheEnd();&#125;void Battle(int Level)&#123; if(Level==1) &#123; srand((int)time(0)); int i=rand(); while(i&lt;1||(i&gt;3&amp;&amp;i&lt;6)||i&gt;8)i=rand(); Fight(i); &#125; if(Level==2) &#123; srand((int)time(0)); int i=rand(); while(i&lt;2||(i&gt;4&amp;&amp;i&lt;7)||i&gt;9)i=rand(); Fight(i); &#125; if(Level==3) &#123; srand((int)time(0)); int i=rand(); while(i&lt;3||(i&gt;5&amp;&amp;i&lt;8)||i&gt;10)i=rand(); Fight(i); &#125; if(Level==4) &#123; srand((int)time(0)); int i=rand(); while(i&lt;4||(i&gt;6&amp;&amp;i&lt;9)||i&gt;11)i=rand(); if(i!=11)Fight(i); else LastFight(); &#125;&#125;void Forest()&#123; Clear(); Slowsay("1.草原（易，怪物级别1~3）"); Slowsay("2.悬崖（中，怪物级别2~4）"); Slowsay("3.洞穴（难，怪物级别3~5）"); Slowsay("4.邪恶基地（极难，怪物级别4~6）"); int x; Slowsay("请输入你想去的地方（序号，1~4）"); x=getch()-48; Battle(x);&#125;void Out()&#123; cout&lt;&lt;"HP:"&lt;&lt;player1.HP&lt;&lt;endl; Sleep(1000); cout&lt;&lt;"MaxHP:"&lt;&lt;player1.MaxHP&lt;&lt;endl; Sleep(1000); cout&lt;&lt;"MP:"&lt;&lt;player1.MP&lt;&lt;endl; Sleep(1000); cout&lt;&lt;"MaxMP:"&lt;&lt;player1.MaxMP&lt;&lt;endl; Sleep(1000); cout&lt;&lt;"ATK:"&lt;&lt;player1.Attack&lt;&lt;endl; Sleep(1000); cout&lt;&lt;"DEF:"&lt;&lt;player1.Defence&lt;&lt;endl; Sleep(1000); cout&lt;&lt;"EXP:"&lt;&lt;player1.Experience&lt;&lt;endl; Sleep(1000); cout&lt;&lt;"LV:"&lt;&lt;player1.Level&lt;&lt;endl; Sleep(1000); cout&lt;&lt;"Money:"&lt;&lt;player1.Money&lt;&lt;endl; Sleep(6000);&#125;int Money(int i)&#123; srand((int)time(0)); return rand();&#125;void Pets()&#123; Slowsay("请输入你想将宠物提升到？级"); int x; x=getch()-48; if(x&gt;30)Slowsay("宠物满级30级，输入无效"); else &#123; long long Need=10*pow(3,x); say("需要"); printf("%lld",Need); Slowsay("元钱"); if(player1.Money&lt;Need)Slowsay("金钱不足，升级失败"); else &#123; Slowsay("升级成功"); player1.PetLevel+=x; &#125; &#125;&#125;void Home()&#123; while(1) &#123; Clear(); Slowsay("1.从家长那里拿点零花钱"); Slowsay("2.睡觉"); Slowsay("3.升级圣坛"); Slowsay("4.查看状态"); Slowsay("5.升级宠物"); Slowsay("6.返回"); int x; Slowsay("请输入你想去的地方（序号，1~6）"); x=getch()-48; if(x==6)break; if(x==1) &#123; Slowsay("你必须要回答出我的问题，不然就滚！"); srand((int)time(0)); int i=rand()%5; cout&lt;&lt;Question[i]; string a; cin&gt;&gt;a; if(a==Answer[i]) &#123; srand((int)time(0)); int x=Money(i); say("真棒，");printf("%d",x);Slowsay("元就给你了"); player1.Money+=x; &#125; else Slowsay("这都能错，滚！"); &#125; if(x==2) &#123; Slowsay("多么一个好觉啊，你的血量回满了"); player1.HP=player1.MaxHP; &#125; if(x==3)Level(); if(x==4)Out(); if(x==5)Pets(); &#125;&#125;void Class()&#123; while(1) &#123; Clear(); Slowsay("这里就是我的教室了，找个人聊聊天吧"); Slowsay("1.老师"); Slowsay("2.同桌"); Slowsay("3.死党"); Slowsay("4.学霸"); Slowsay("5.返回"); int x; Slowsay("请输入你想要对话的人（序号，1~5）"); x=getch()-48; if(x==5)break; if(x==1)Slowsay("你找我干什么，滚！"); if(x==2)Slowsay("你的死党好像不高兴，去看看吧"); if(x==3&amp;&amp;(Mission1Get==-1||Mission1Get==1))Slowsay("我没事儿，你走吧"); if(x==3&amp;&amp;Mission1Get==0) &#123; Slowsay("学霸这次又考第一，我们去教训他吧"); Slowsay("接到任务：去图书馆教训学霸"); Mission1Get=1; &#125; if(x==4)Slowsay("哈哈，这次我又是第一，太高兴了！"); &#125;&#125;void Study()&#123; if(Mission1Get)if(Fight(12)==1)Mission1Get=-1; while(1) &#123; Clear(); srand((int)time(0)); Slowsay("1.学习火球术"); Slowsay("2.学习雷暴术"); Slowsay("3.学习治疗术"); Slowsay("4.学习"); Slowsay("5.返回"); int x; Slowsay("请输入你想执行的操作（序号，1~5）"); x=getch()-48; if(x==5)break; if(x==1) &#123; int i=rand()%2; if(i) &#123; player1.SKill1Level++; say("学习成功，火球术升至");printf("%lld",player1.SKill1Level);Slowsay("级"); &#125; else Slowsay("学习失败"); &#125; if(x==2) &#123; int i=rand()%2; if(i) &#123; player1.SKill2Level++; say("学习成功，雷暴术升至");printf("%lld",player1.SKill2Level);Slowsay("级"); &#125; else Slowsay("学习失败"); &#125; if(x==3) &#123; int i=rand()%2; if(i) &#123; player1.SKill3Level++; say("学习成功，治疗术升至");printf("%lld",player1.SKill3Level);Slowsay("级"); &#125; else Slowsay("学习失败"); &#125; if(x==4) &#123; Slowsay("#include&lt;bits/stdc++.h&gt;int main()&#123;int a,b;cin&gt;&gt;a&gt;&gt;b;cout&lt;&lt;a+b;&#125;"); player1.Experience+=20; &#125; &#125;&#125;void Eat()&#123; Clear(); Slowsay("1.黄瓜炒茄子（10元）"); Slowsay("2.茄子煮蛋（30元）"); Slowsay("3.黄瓜蒸蛋（50元）"); Slowsay("4.红烧水饺（100元）"); Slowsay("5.清蒸面条（200元）"); Slowsay("6.黑暗妙趣角（250元）"); int x; Slowsay("请输入你想吃的食物（序号，1~6）"); x=getch()-48; if(x==1)player1.Money-=10; if(x==2)player1.Money-=30; if(x==3)player1.Money-=50; if(x==4)player1.Money-=100; if(x==5)player1.Money-=200; if(x==6&amp;&amp;!EatingGet) &#123; player1.Money+=250; Slowsay("恭喜你获得成就“不要命”，获得奖金500元"); EatingGet=1; &#125; if(x==6&amp;&amp;EatingGet)player1.Money-=250; Slowsay("吃饭成功");&#125;void School()&#123; while(1) &#123; Clear(); Slowsay("1.图书馆（增加经验、学习技能）"); Slowsay("2.教室（聊天）"); Slowsay("3.食堂（吃奇怪的食物）"); Slowsay("4.返回"); int x; Slowsay("请输入你想去的地方（序号，1~4）"); x=getch()-48; if(x==1)Study(); if(x==2)Class(); if(x==3)Eat(); if(x==4)break; &#125;&#125;void Work()&#123; Clear(); Slowsay("1.搬砖 5HP/10元 成功率66%"); Slowsay("2.看店 5HP/20元 成功率50%"); if(WorkOpen)Slowsay("3.抄作业 5HP/100元 成功率100%，但是需要密码"); int x; if(WorkOpen)Slowsay("请输入你想做的工作（序号，1~3）"); else Slowsay("请输入你想做的工作（序号，1~2）"); srand((int)time(0)); x=getch()-48; if(x==1) &#123; int i=rand()%3; if(i&lt;2) &#123; Slowsay("搬砖成功"); player1.HP-=5; player1.Money+=10; &#125; else Slowsay("搬砖失败"); &#125; if(x==2) &#123; int i=rand()%2; if(!i) &#123; Slowsay("看店成功"); player1.HP-=5; player1.Money+=20; &#125; else Slowsay("看店失败"); &#125; if(x==3&amp;&amp;WorkOpen) &#123; Slowsay("请输入密码："); char x[200]; int len; while(x[len]!='\n') &#123; x[++len]=getch(); putchar('*'); &#125; bool ok=0; for(int i=1;i&lt;=len-1;++i)if(x[i]!=PassWord[i-1])ok=0; if(x[len]!='\n')ok=0; if(!ok)Slowsay("密码错误"); else &#123; Slowsay("密码正确，抄作业成功"); player1.HP-=5; player1.Money+=100; &#125; &#125; if(player1.HP&lt;=0)Die();&#125;void Shop()&#123; while(1) &#123; Clear(); Slowsay("1.小血瓶 +10点血 10元"); Slowsay("2.中血瓶 +20点血 20元"); Slowsay("3.大血瓶 +50点血 50元"); Slowsay("4.小魔瓶 +10点蓝 10元"); Slowsay("5.中魔瓶 +20点蓝 20元"); Slowsay("6.大魔瓶 +50点蓝 50元"); Slowsay("7.小炸弹 50点伤害 10元"); Slowsay("8.中炸弹 100点伤害 20元"); Slowsay("9.大炸弹 200点伤害 50元"); Slowsay("+.原子弹 500点伤害 200元"); Slowsay("*.返回"); if(!ForestOpen)Slowsay("-.神秘钥匙"); int x,y; if(!ForestOpen)Slowsay("请输入你想买的东西（序号，1~9、+、*、-）"); else Slowsay("请输入你想买的东西（序号，1~9、+、*）"); x=getch(); if(x=='*')break; if(x!='-')Slowsay("请输入你想购买的数量"); y=getch()-48; if(y==0)continue; if(x=='+') &#123; if(player1.Money&gt;=200*y) &#123; Slowsay("购买成功"); player1.Money-=200*y; player1.SuperAttack+=y; &#125; else Slowsay("金钱不足，购买失败"); &#125; if(x=='-'&amp;&amp;!ForestOpen) &#123; if(player1.Money&gt;=100000) &#123; Slowsay("购买成功，森林已解锁"); player1.Money-=100000; ForestOpen=1; &#125; else Slowsay("金钱不足，购买失败"); &#125; x-=48; if(x==1) &#123; if(player1.Money&gt;=10*y) &#123; Slowsay("购买成功"); player1.Money-=10*y; player1.SmallHP+=y; &#125; else Slowsay("金钱不足，购买失败"); &#125; if(x==2) &#123; if(player1.Money&gt;=20*y) &#123; Slowsay("购买成功"); player1.Money-=20*y; player1.MiddleHP+=y; &#125; else Slowsay("金钱不足，购买失败"); &#125; if(x==3) &#123; if(player1.Money&gt;=50*y) &#123; Slowsay("购买成功"); player1.Money-=50*y; player1.LargeHP+=y; &#125; else Slowsay("金钱不足，购买失败"); &#125; if(x==4) &#123; if(player1.Money&gt;=10*y) &#123; Slowsay("购买成功"); player1.Money-=10*y; player1.SmallMP+=y; &#125; else Slowsay("金钱不足，购买失败"); &#125; if(x==5) &#123; if(player1.Money&gt;=20*y) &#123; Slowsay("购买成功"); player1.Money-=20*y; player1.MiddleMP+=y; &#125; else Slowsay("金钱不足，购买失败"); &#125; if(x==6) &#123; if(player1.Money&gt;=50*y) &#123; Slowsay("购买成功"); player1.Money-=50*y; player1.LargeMP+=y; &#125; else Slowsay("金钱不足，购买失败"); &#125; if(x==7) &#123; if(player1.Money&gt;=10*y) &#123; Slowsay("购买成功"); player1.Money-=10*y; player1.SmallAttack+=y; &#125; else Slowsay("金钱不足，购买失败"); &#125; if(x==8) &#123; if(player1.Money&gt;=20*y) &#123; Slowsay("购买成功"); player1.Money-=20*y; player1.MiddleAttack+=y; &#125; else Slowsay("金钱不足，购买失败"); &#125; if(x==9) &#123; if(player1.Money&gt;=50*y) &#123; Slowsay("购买成功"); player1.Money-=50*y; player1.LargeAttack+=y; &#125; else Slowsay("金钱不足，购买失败"); &#125; &#125;&#125;void Bets()&#123; Clear(); srand((int)time(0)); Slowsay("1.猜大小"); Slowsay("2.猜点数"); int x,y,z; Slowsay("请输入你想赌的方式（序号，1~2）"); x=getch()-48; Slowsay("请输入你想下注的金额"); y=getch()-48; if(x==1) &#123; Slowsay("猜大还是小？1大，2小"); z=getch()-48; srand((int)time(0)); int a1=rand()%6,a2=rand()%6; if(a1==0)a1=6; if(a2==0)a2=6; if((a1+a2&gt;6&amp;&amp;z==1)||(a1+a2&lt;=6&amp;&amp;z==2)) &#123; Slowsay("你赢了，这些钱给你"); player1.Money+=y; &#125; else &#123; Slowsay("你输了，这些钱我拿走了"); player1.Money-=y; &#125; &#125; if(x==2) &#123; srand((int)time(0)); int a1=rand()%6; if(a1==0)a1=6; Slowsay("你想猜多少点？"); z=getch()-48; if(z==a1) &#123; Slowsay("你赢了，这些钱给你"); player1.Money+=y; &#125; else &#123; Slowsay("你输了，这些钱我拿走了"); player1.Money-=y; &#125; &#125;&#125;void City()&#123; while(1) &#123; Clear(); Slowsay("1.打工"); Slowsay("2.商店"); Slowsay("3.赌博"); Slowsay("4.返回"); int x; Slowsay("请输入你想去的地方（序号，1~4）"); x=getch()-48; if(x==4)break; if(x==1)Work(); if(x==2)Shop(); if(x==3)Bets(); &#125;&#125;void SpecialFight()&#123; Clear(); int HP=1000; int Attack=100; int Defence=100; int stop=0,burn=0,blood=0; if(player1.PetKind==4) &#123; say("你的宠物狴犴使对方攻击降低"); printf("%lld",player1.PetLevel*10); Slowsay("点攻击"); Attack-=player1.PetLevel*8; &#125; while(HP&gt;0&amp;&amp;player1.HP&gt;0) &#123; Clear(); Slowsay("请输入你想执行的操作："); Slowsay("1：攻击 2：使用技能"); int x,End=1; x=getch()-48; if(x&lt;0||x&gt;2)continue; if(x==1) &#123; if(player1.Attack&lt;Defence) &#123; say("攻击小于对手防御，建议逃跑或使用道具"); printf("\n"); &#125; else &#123; int t=min(HP,player1.Attack-Defence); HP-=t; say("对敌人造成");printf("%d",t);say("点伤害"); printf("\n"); &#125; &#125; if(x==2) &#123; say("请输入想要使用的技能编号:(1为火球术,2为雷暴术,3为治疗术,4为专属技能)"); printf("\n"); int y; y=getch()-48; if(y==1&amp;&amp;!player1.SKill1Level) &#123; say("火球术尚未学习！"); printf("\n"); End=0; &#125; if(y==2&amp;&amp;!player1.SKill2Level) &#123; say("雷暴术尚未学习！"); printf("\n"); End=0; &#125; if(y==3&amp;&amp;!player1.SKill3Level) &#123; say("治疗术尚未学习！"); printf("\n"); End=0; &#125; if(y==1&amp;&amp;player1.SKill1Level) &#123; if(player1.MP&lt;3) &#123; say("魔法值不足，使用失败"); printf("\n"); End=0; &#125; else &#123; say("使用火球术，对敌人造成");printf("%lld",5*player1.SKill1Level*int(player1.SkillUp+1));say("点伤害"); printf("\n"); say("消耗3点魔法值"); printf("\n"); HP-=5*player1.SKill1Level*int(player1.SkillUp+1); player1.MP-=3; &#125; &#125; if(y==2&amp;&amp;player1.SKill2Level) &#123; if(player1.MP&lt;5) &#123; say("魔法值不足，使用失败"); printf("\n"); End=0; &#125; else &#123; say("使用雷暴术，对敌人造成");printf("%lld",10*player1.SKill2Level*int(player1.SkillUp+1));say("点伤害"); printf("\n"); say("消耗5点魔法值"); printf("\n"); HP-=10*player1.SKill2Level*int(player1.SkillUp+1); player1.MP-=5; &#125; &#125; if(y==3&amp;&amp;player1.SKill3Level) &#123; if(player1.MP&lt;10) &#123; say("魔法值不足，使用失败"); printf("\n"); End=0; &#125; else &#123; say("使用治疗术，回复");printf("%lld",15*player1.SKill3Level*int(player1.SkillUp+1));say("点血量"); printf("\n"); say("消耗10点魔法值"); printf("\n"); player1.HP=min(player1.MaxHP,player1.HP+15*player1.SKill3Level*int(player1.SkillUp+1)); player1.MP-=10; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==1&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;20) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) &#123; HP-=player1.OwnSkillLevel*50; stop=1; &#125; if(player1.OwnSkill==2) HP-=player1.OwnSkillLevel*(player1.Attack-Defence); player1.MP-=20; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==2&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;20) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) HP-=player1.OwnSkillLevel*50; if(player1.OwnSkill==2) &#123; HP-=player1.OwnSkillLevel*(player1.Attack-Defence); stop=1; &#125; player1.MP-=20; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==3&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;20) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) &#123; HP-=player1.OwnSkillLevel*50; blood=2; &#125; if(player1.OwnSkill==2) HP-=player1.OwnSkillLevel*(player1.Attack-Defence); player1.MP-=20; &#125; &#125; if(y==4&amp;&amp;player1.Vocation==4&amp;&amp;player1.OwnSkill!=3) &#123; if(player1.MP&lt;30) &#123; Slowsay("魔法值不足，使用失败"); End=0; &#125; else &#123; say("使用");say(player1.OwnSkillName); say("，对敌人造成"); if(player1.OwnSkill==1) &#123; HP-=player1.OwnSkillLevel*45; burn=3; &#125; if(player1.OwnSkill==2) &#123; HP-=player1.OwnSkillLevel*(player1.Attack-Defence); stop=1; &#125; player1.MP-=30; &#125; &#125; &#125; if(End) &#123; if(player1.PetKind==1) &#123; say("你的宠物麒麟对黑衣男子造成了"); printf("%lld",min(20*player1.PetLevel,HP)); Slowsay("点伤害"); HP-=min(20*player1.PetLevel,HP); &#125; if(player1.PetKind==3) &#123; say("你的宠物狻猊对黑衣男子造成了"); printf("%lld",min(15*player1.PetLevel+100,HP)); Slowsay("点伤害"); HP-=min(15*player1.PetLevel+100,HP); &#125; if(player1.PetKind==2) &#123; say("你的宠物饕餮给你回了"); printf("%lld",player1.PetLevel*10); Slowsay("点血"); player1.HP+=player1.PetLevel*10; &#125; if(!stop) &#123; player1.HP-=Attack-player1.Defence&lt;0?0:Attack-player1.Defence; say("黑衣男子对你造成了");printf("%lld",Attack-player1.Defence&lt;0?0:Attack-player1.Defence);say("点伤害"); printf("\n"); &#125; if(stop) &#123; stop=0; Slowsay("黑衣男子被你定住，无法攻击"); &#125; if(blood) &#123; --blood; HP-=40; Slowsay("黑衣男子受到了40点流血伤害"); &#125; if(burn) &#123; --burn; HP-=30; Slowsay("黑衣男子受到了30点灼烧伤害"); &#125; &#125; &#125; if(player1.HP&lt;=0)Die(); else &#123; Clear(); Slowsay("黑衣男子：不错嘛，小伙子！居然能战胜我！这里是100000元，就送你了！"); Slowsay("少年：真的吗！谢谢大叔！"); Slowsay("黑衣男子（默想）：不愧是天选之子啊！看来，他能救出公主！"); player1.Money+=100000; Special=1; &#125;&#125;void Story1()&#123; if(Special) &#123; Clear(); Slowsay("这里什么也没有"); Slowsay("少年陷入了沉思：那个穿黑衣服的大叔呢？"); Slowsay("他可是个好人......"); return; &#125; Clear(); Slowsay("少年：那个穿黑衣服的，你是谁？"); Slowsay("黑衣男子：你无需知道我是谁，因为你马上就会变成一具尸体！"); Slowsay("少年：你好大的口气，早晨没刷牙吧！"); Slowsay("黑衣男子：废话少说，看招！"); SpecialFight();&#125;void SuperFight()&#123; Slowsay("精英关共有3关，中途死亡也没关系，回到原界面"); Slowsay("通关后获得丰厚奖励"); Slowsay("第一关：神圣狮子王；第二关：神圣石怪王；第三关：混沌魔王"); Fight(5); Fight(10); LastFight(); player1.Attack+=2333; player1.Defence+=2333; player1.HP=player1.MaxHP+=2333; player1.MP=player1.MaxMP+=2333;&#125;void ChangeLog()&#123; while(1) &#123; Slowsay("您想查看那个版本的更新？（输入0退出）"); double x; scanf("%lf",&amp;x); if(x==0.0)break; if(x&lt;1.6) &#123; Slowsay("抱歉，v1.6起才支持查看更新"); continue; &#125; if(x&gt;1.7) &#123; Slowsay("对不起，我还没更新到此版本"); continue; &#125; if(x==1.6) &#123; Slowsay("对不起，咕咕了这么久，对于追玩的朋友表示抱歉"); Slowsay("加入新职业：魔法师"); Slowsay("大更战斗系统（向RPG靠拢）"); Slowsay("对其他职业进行修改"); Slowsay("修复抄作业没有输入的问题"); Slowsay("总体来说耗时不长，码量巨大"); &#125; if(x==1.7) &#123; Slowsay("增加了更人性化的设置系统"); Slowsay("修复部分已知Bug并进行优化"); Slowsay("感谢@空界_无尽和@louis_zhq"); &#125; &#125;&#125;void Settings()&#123; Slowsay("设置内容如下：1.语速 2.颜色"); int x; x=getch()-48; if(x==1) &#123; Slowsay("请输入语速："); int y; scanf("%d",&amp;y); player1.SpeakSpeed=y; Slowsay("语速设置成功！"); &#125; if(x==2) &#123; Slowsay("请输入颜色："); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); Slowsay("1.白色"); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED); Slowsay("2.红色"); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_GREEN); Slowsay("3.绿色"); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_BLUE); Slowsay("4.蓝色"); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN); Slowsay("5.黄色"); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_BLUE); Slowsay("6.粉色"); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE); Slowsay("7.青色"); int y; y=getch()-48; if(y==1)SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); if(y==2)SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED); if(y==3)SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_GREEN); if(y==4)SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_BLUE); if(y==5)SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN); if(y==6)SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_BLUE); if(y==7)SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE); if(y&gt;0&amp;&amp;y&lt;8)Slowsay("颜色设置成功！"); if(y&lt;=0||y&gt;=8)Slowsay("输入颜色错误！"); &#125;&#125;void MainMenu()&#123; Clear(); Slowsay("1.森林（打怪）"); Slowsay("2.家（存档、睡觉等）"); Slowsay("3.学校（学习、吃奇怪的食物等）"); Slowsay("4.市中心（打工、买东西等）"); Slowsay("5.小巷子（未知）"); Slowsay("6.精英关（通关后有丰厚奖励）"); Slowsay("7.更新日志（v1.6起）"); Slowsay("8.设置"); Slowsay("9.结束游戏（自动保存）"); int x; Slowsay("请输入你想去的地方（序号，1~9）"); x=getch()-48; if(x==1&amp;&amp;ForestOpen)Forest(); if(x==1&amp;&amp;!ForestOpen)Slowsay("暂时无法进入，似乎需要什么神秘的钥匙"); if(x==2)Home(); if(x==3)School(); if(x==4)City(); if(x==5)Story1(); if(x==6)SuperFight(); if(x==7)ChangeLog(); if(x==8)Settings(); if(x==9) &#123; Save(); life=0; &#125;&#125;int main()&#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); Slowsay(" $$$天选之子v1.7$$$ "); Slowsay("作者：JXH 洛谷ID：地表最弱蒟蒻 QQ号：最好别加"); Sleep(5000); system("cls"); if(MessageBox(NULL,"是否读取存档？","天选之子",MB_YESNO)==6)Read(); else &#123; player1.Attack=5; player1.HP=player1.MaxHP=player1.MaxMP=player1.MP=50; player1.Defence=player1.LargeAttack=player1.LargeHP=0; player1.LargeMP=player1.MiddleAttack=player1.MiddleHP=0; player1.MiddleMP=player1.SKill1Level=player1.SKill2Level=0; player1.SKill3Level=player1.SmallAttack=player1.SmallMP=0; player1.SuperAttack=0; Start(); &#125; while(life)MainMenu();&#125;/*TODO:更新剧情TODO:加入新职业FIXME:剧情什么的闪的太快了，还有打完怪后的文字也看不清（基本修复）*/]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P1636【Einstein学画画】]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3P1636%E3%80%90Einstein%E5%AD%A6%E7%94%BB%E7%94%BB%E3%80%91%2F</url>
    <content type="text"><![CDATA[虽然跟楼上各位写得差不多，但是！我使用了无敌的位运算！其实很简单（没什么用……）在此，先解释一下按位与（&amp;）：,a&amp;b是指将a，b分别转为二进制，然后逐位比较，如两者的同位皆为1，则结果的该位为1，否则为0。 那么，可以看出%2为1的数二进制末尾必为1，否则必为0，1&amp;1为1,0&amp;1为0，那么该数&amp;1的结果即可判断奇偶性。 综上所述：a&amp;1=1，a为奇数，否则，a为偶数位运算大法好！！！ 闲话不多说，下面奉上代码： 1234567891011121314151617181920212223#include&lt;cstdio&gt;//位运算大法好 inline void read(int &amp;a)//快速读入 &#123; int k=1;//系数 char c=getchar();a=0;//定义字符，并进行第一次读入 while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')k=-1;c=getchar();&#125;//如果不为数字，继续读入，特判：如为-号，系数变为-1 while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;a=a*10+c-'0';c=getchar();&#125;//如果是数字，需将变量*10+当前数字 a*=k;//乘上系数 &#125;int s,n,m,a,b,f[1010];//定义变量，s为度为奇数点总数，n，m变量见题意，a，b是读入的边的两端点，f数组统计点度数 int main()&#123; read(n);read(m);//懒得解释 for(int i=1;i&lt;=m;i++) &#123; read(a);read(b);//读入 f[a]++; f[b]++;//两点的度+1 &#125; for(int i=1;i&lt;=n;i++)if(f[i]&amp;1)s++;//如果当前点度为奇数，s++ printf("%d",s?s/2:1);//输出s/2（s=0时输出1）（其中s为0或2时，能一笔画，故输出结果为1，这样快一些，又短） //注意：这里使用了位运算！具体方法见上面说明！ &#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P2036【Perket】]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3P2036%E3%80%90Perket%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题一看就知道要用DFS，其实也可以算作是一题新手练手题吧，练练DFS有人说可以暴力？！反正我只会DFS…… 第二篇题解，各位神犇dalao们请谅解（好像两篇都是DFS?） 废话不多说，下面奉上我的AC代码（具体说明见注释）： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;//头文件，min和abs在algorithm中（STL大法好）！struct perket//定义结构体&#123; int sour,sweet;//sour表示酸度，sweet表示甜度&#125;a[11];//配料int s=1,w,ans=2147483646,n;//ans一开始开2147483647莫名RE，用2147483646就好了。。。。。。long long ok;//ok表示所用配料数inline void read(int &amp;a)//这里详细解释一下快速读入，inline的作用为加快该函数所用时间，注意：若不止一个输入输出文件，则不可用inline！&#123; char c;//定义字符存储变量 int k=1;a=0;//定义系数（初始为1）与所读入变量 c=getchar();//读入字符 while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')k=-1;c=getchar();&#125;//如果该字符不为数字，跳过该字符，注意：由于本题有负数，所以要加判断是否为-号，如为-号，系数变为-1 while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;a=a*10+c-'0';c=getchar();&#125;//如果该字符为数字，原数*10+该字符-‘0’,其实*10+是特别特别有用的一个东西，不在这里详细论述，以后有时间的话会专门发一篇文章来解释*10+与其作用 a*=k;//原数乘上系数&#125;inline void print(int a)//快速输出&#123; if(a&gt;10)print(a/10);//如果当前该数超过10，输出除个位外部分 putchar(a%10+'0');//输出个位&#125;void DFS(int i)//DFS，i表示当前搜索到第i个配料&#123; if(i==n+1)return ;//如果全部搜索完毕，回溯 s*=a[i].sour;//当前酸度乘上该配料酸度 w+=a[i].sweet;//当前甜度加上该配料甜度 ok++;//所用配料数+1 ans=std::min(ans,abs(s-w));//更新答案，取原答案与甜酸度之差的最小值，有人说可以加一个特判：当ans=0时，直接输出！我没有这么做，因为个人感觉没啥用 DFS(i+1);//向下继续搜索 s/=a[i].sour;//当前酸度除以该配料酸度 w-=a[i].sweet;//当前甜度减去该配料甜度 ok--;//所用配料数-1 //这里解释一下：递归之前改变的值，递归过后一定要改回原值，即使你不再向下搜索，这也是递归的基本特征之一！！！ DFS(i+1);//向下继续搜索，这是为了保证答案的全面性&#125;int main()&#123; read(n); for(int i=1;i&lt;=n;i++)&#123;read(a[i].sour);read(a[i].sweet);&#125;//输入，不解释 DFS(1);//DFS，从第一种配料开始搜索 print(ans);//输出答案&#125; 最后，强调一下：禁止抄袭！禁止抄袭！禁止抄袭！求洛谷一定要给过！]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P2666【Bessie的秘密牧场】]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3P2666%E3%80%90Bessie%E7%9A%84%E7%A7%98%E5%AF%86%E7%89%A7%E5%9C%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题一看就是典型的DFS，而且也不难，一开始暴力做了一遍60分，后来DFS一遍就AC了。（搜索面积，只不过在常规上加了一个for循环）下面送上DFS的简单AC代码：（1764ms，有点慢）抵抗打表，推崇深搜！ 123456789101112131415#include&lt;cstdio&gt;#include&lt;cmath&gt;int n,z;//z为方案总数，n见题意void DFS(int x,int s)//x表示当前已搜索的块数，s表示目前的总面积&#123; if(x==4)if(s==n)z++;else;//如果已搜索4块而且目前总面积正好为n，方案数+1，else；是为了让下一个else与前一个if配对（典型的空语句应用，也可用if(x==4)&#123;if(s==n)z++;&#125;来表示） else for(int i=0;i&lt;=sqrt(n);i++)DFS(x+1,s+i*i);//i循环从0到根号n，（i为边长，因为可以有周长为0的草皮），每次搜索下一个，当前总面积加上i的平方，看了其他题解，是先加上，递归完了再减，不如这样直接作为形参来得方便（不过好像慢一点？不存在的！）&#125;int main()&#123; scanf("%d",&amp;n);//输入 DFS(0,0);//初始未搜索，一开始一共搜索0块，总面积当然也为0 printf("%d",z);//输出 return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello!]]></title>
    <url>%2FHello%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客123456#include&lt;bits/stdc++.h&gt;int main()&#123; printf("Hello World!"); return 0;&#125; $\text{HelloWorld!}$ Hello!]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
