<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法导论——模拟退火]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%2F</url>
    <content type="text"><![CDATA[今天来说一个玄学算法：模拟退火！（真·玄学）先说一说它的名称来源：$Link$ 退火是一种金属热处理工艺，指的是将金属缓慢加热到一定温度，保持足够时间，然后以适宜速度冷却。…… 这貌似和$OI$毫无关系啊……，再看看模拟退火？$Link$ 模拟退火（$Simulate Anneal$，$SA$）的出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性。模拟退火算法是一种通用的优化算法，其物理退火过程由加温过程、等温过程、冷却过程这三部分组成。 这……还真有关系，而且就是思路 下面解释一下模拟退火的几个特点： 非酋不建议使用，看脸 选一个好的随机种子很重要，当然srand(time(NULL))也可以（本人使用） 日常调参（降温系数，初温，末温，次数） 如果当前值更优，则无条件将当前值作为最优解，并接受，否则以一定概率接受当前值（概率与温度有关） 一次难以出正解 欧皇除外 下面附图，便于理解： 看得出，高温时答案会不断跳动 但随着温度降低，逐渐在最优解附近稳定 （当然，正常情况下，常会误入歧途，跑到次优解去了） 步骤： 随机选一个 如果当前值更优，则无条件将当前值作为最优解，并接受，否则以一定概率接受当前值（概率与温度有关） 降温，如果温度低于末温，结束 附常用参数： 降温系数 $0.993$ ~ $0.998$ 初温 $2000$ ~ $5000$ 末温 $1e-13$ ~ $1e-17$ 次数 $3$ ~ $20$ 对于调参： 如果您脸黑没有$AC$，可以调大初温或调小末温 如果您时间充裕，也可以多跑几次或者调大降温系数 附上本人P1337[JSOI2004]平衡点/吊打XXXAC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define cold 0.997#define temperature 3000#define lastemp 1e-15#define times 3#define INF 1&lt;&lt;30using namespace std;struct node&#123; int x,y,w;&#125;a[1001];int n;double t,tx,ty,tw,ansx,ansy,anse;double energy(double x,double y)&#123; double e=0; for(int i=1;i&lt;=n;++i) &#123; tx=x-a[i].x; ty=y-a[i].y; tw=a[i].w; e+=sqrt(tx*tx+ty*ty)*tw ; &#125; return e;&#125;void SA()&#123; t=temperature; while(t&gt;lastemp) &#123; double nx=ansx+((rand()*2)-RAND_MAX)*t; double ny=ansy+((rand()*2)-RAND_MAX)*t; double ne=energy(nx,ny); if(ne&lt;anse)ansx=nx,ansy=ny,anse=ne; else if(exp((anse-ne)/t)*RAND_MAX&gt;rand())ansx=nx,ansy=ny; t*=cold; &#125;&#125;int main()&#123; srand(time(NULL)); cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].w; ansx+=a[i].x; ansy+=a[i].y; &#125; ansx/=n; ansy/=n; anse=energy(ansx,ansy); for(int i=1;i&lt;=times;++i)SA(); printf("%.3lf %.3lf",ansx,ansy); return 0;&#125; 跑得稍微有点慢，共计$1200ms$多，但都每个点不超过$400ms$，如果有巨佬有更优参数可以在评论里告诉我（该题某篇题解参数亲测不行） 一些问题与回答 $Q$：如果调参调到极限还是不能$AC$怎么办？ $A$：您太非了 试试多交几次或者换个随机种子 （随机种子例子：$19**17$，$233333$，$114 *$） $Q$：怎么调参？ $A$：看心情 在保证$AC$的情况下，尽量调小一些 $Q$：如果无论如何都$AC$不了呢？ $A$：您可以去非洲了 （叹气）您还是去打正解吧 习题：P2503[HAOI2006]均分数据 （闲话：模拟退火英文名$SA$，即$Simulate Anneal$，就是模拟+退火）]]></content>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天选之子v1.7.2]]></title>
    <url>%2F%E5%A4%A9%E9%80%89%E4%B9%8B%E5%AD%90v1-7-2%2F</url>
    <content type="text"><![CDATA[见代码（修复了一些Bug，感谢@fzhfzh 和@gongcharlie ）]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P1636【Einstein学画画】]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3P1636%E3%80%90Einstein%E5%AD%A6%E7%94%BB%E7%94%BB%E3%80%91%2F</url>
    <content type="text"><![CDATA[虽然跟楼上各位写得差不多，但是！我使用了无敌的位运算！其实很简单（没什么用……）在此，先解释一下按位与（&amp;）：,a&amp;b是指将a，b分别转为二进制，然后逐位比较，如两者的同位皆为1，则结果的该位为1，否则为0。 那么，可以看出%2为1的数二进制末尾必为1，否则必为0，1&amp;1为1,0&amp;1为0，那么该数&amp;1的结果即可判断奇偶性。 综上所述：a&amp;1=1，a为奇数，否则，a为偶数位运算大法好！！！ 闲话不多说，下面奉上代码： 1234567891011121314151617181920212223#include&lt;cstdio&gt;//位运算大法好 inline void read(int &amp;a)//快速读入 &#123; int k=1;//系数 char c=getchar();a=0;//定义字符，并进行第一次读入 while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')k=-1;c=getchar();&#125;//如果不为数字，继续读入，特判：如为-号，系数变为-1 while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;a=a*10+c-'0';c=getchar();&#125;//如果是数字，需将变量*10+当前数字 a*=k;//乘上系数 &#125;int s,n,m,a,b,f[1010];//定义变量，s为度为奇数点总数，n，m变量见题意，a，b是读入的边的两端点，f数组统计点度数 int main()&#123; read(n);read(m);//懒得解释 for(int i=1;i&lt;=m;i++) &#123; read(a);read(b);//读入 f[a]++; f[b]++;//两点的度+1 &#125; for(int i=1;i&lt;=n;i++)if(f[i]&amp;1)s++;//如果当前点度为奇数，s++ printf("%d",s?s/2:1);//输出s/2（s=0时输出1）（其中s为0或2时，能一笔画，故输出结果为1，这样快一些，又短） //注意：这里使用了位运算！具体方法见上面说明！ &#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P2036【Perket】]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3P2036%E3%80%90Perket%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题一看就知道要用DFS，其实也可以算作是一题新手练手题吧，练练DFS有人说可以暴力？！反正我只会DFS…… 第二篇题解，各位神犇dalao们请谅解（好像两篇都是DFS?） 废话不多说，下面奉上我的AC代码（具体说明见注释）： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;//头文件，min和abs在algorithm中（STL大法好）！struct perket//定义结构体&#123; int sour,sweet;//sour表示酸度，sweet表示甜度&#125;a[11];//配料int s=1,w,ans=2147483646,n;//ans一开始开2147483647莫名RE，用2147483646就好了。。。。。。long long ok;//ok表示所用配料数inline void read(int &amp;a)//这里详细解释一下快速读入，inline的作用为加快该函数所用时间，注意：若不止一个输入输出文件，则不可用inline！&#123; char c;//定义字符存储变量 int k=1;a=0;//定义系数（初始为1）与所读入变量 c=getchar();//读入字符 while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')k=-1;c=getchar();&#125;//如果该字符不为数字，跳过该字符，注意：由于本题有负数，所以要加判断是否为-号，如为-号，系数变为-1 while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;a=a*10+c-'0';c=getchar();&#125;//如果该字符为数字，原数*10+该字符-‘0’,其实*10+是特别特别有用的一个东西，不在这里详细论述，以后有时间的话会专门发一篇文章来解释*10+与其作用 a*=k;//原数乘上系数&#125;inline void print(int a)//快速输出&#123; if(a&gt;10)print(a/10);//如果当前该数超过10，输出除个位外部分 putchar(a%10+'0');//输出个位&#125;void DFS(int i)//DFS，i表示当前搜索到第i个配料&#123; if(i==n+1)return ;//如果全部搜索完毕，回溯 s*=a[i].sour;//当前酸度乘上该配料酸度 w+=a[i].sweet;//当前甜度加上该配料甜度 ok++;//所用配料数+1 ans=std::min(ans,abs(s-w));//更新答案，取原答案与甜酸度之差的最小值，有人说可以加一个特判：当ans=0时，直接输出！我没有这么做，因为个人感觉没啥用 DFS(i+1);//向下继续搜索 s/=a[i].sour;//当前酸度除以该配料酸度 w-=a[i].sweet;//当前甜度减去该配料甜度 ok--;//所用配料数-1 //这里解释一下：递归之前改变的值，递归过后一定要改回原值，即使你不再向下搜索，这也是递归的基本特征之一！！！ DFS(i+1);//向下继续搜索，这是为了保证答案的全面性&#125;int main()&#123; read(n); for(int i=1;i&lt;=n;i++)&#123;read(a[i].sour);read(a[i].sweet);&#125;//输入，不解释 DFS(1);//DFS，从第一种配料开始搜索 print(ans);//输出答案&#125; 最后，强调一下：禁止抄袭！禁止抄袭！禁止抄袭！求洛谷一定要给过！]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P2666【Bessie的秘密牧场】]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3P2666%E3%80%90Bessie%E7%9A%84%E7%A7%98%E5%AF%86%E7%89%A7%E5%9C%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题一看就是典型的DFS，而且也不难，一开始暴力做了一遍60分，后来DFS一遍就AC了。（搜索面积，只不过在常规上加了一个for循环）下面送上DFS的简单AC代码：（1764ms，有点慢）抵抗打表，推崇深搜！ 123456789101112131415#include&lt;cstdio&gt;#include&lt;cmath&gt;int n,z;//z为方案总数，n见题意 void DFS(int x,int s)//x表示当前已搜索的块数，s表示目前的总面积&#123; if(x==4)if(s==n)z++;else;//如果已搜索4块而且目前总面积正好为n，方案数+1，else；是为了让下一个else与前一个if配对（典型的空语句应用，也可用if(x==4)&#123;if(s==n)z++;&#125;来表示） else for(int i=0;i&lt;=sqrt(n);i++)DFS(x+1,s+i*i);//i循环从0到根号n，（i为边长，因为可以有周长为0的草皮），每次搜索下一个，当前总面积加上i的平方，看了其他题解，是先加上，递归完了再减，不如这样直接作为形参来得方便（不过好像慢一点？不存在的！）&#125;int main()&#123; scanf("%d",&amp;n);//输入 DFS(0,0);//初始未搜索，一开始一共搜索0块，总面积当然也为0 printf("%d",z);//输出 return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello!]]></title>
    <url>%2FHello%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客123456#include&lt;bits/stdc++.h&gt;int main()&#123; printf("Hello World!"); return 0;&#125; $\text{HelloWorld!}$ Hello!]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
